#version 450

#define MAX_NUM_CHARS 1 

#define LOCAL_X_DIM 64 
#define LOCAL_Y_DIM 6
#define LOCAL_Z_DIM 1
#define THREAD_COUNT (LOCAL_X_DIM * LOCAL_Y_DIM * LOCAL_Z_DIM)
#define BLOCK_SIZE 192
//#define BLOCK_SIZE 128

#define FAR 3
#define BAND_NEW 2
#define BAND 1
#define KNOWN 0
//#define KNOWN_NEW 1
//#define NEW_BAND 2
#define DEBUG_OFFSET 0.07

struct FMM_Node {
    float value;
    uint tag;
};

struct FMM_Block {
    uint index;
    uint band_points_count;
};

struct OutputVertex {
    vec3 pos;
    uint color_point_size;
};

struct Vertex_vvvvnnnn {
    vec4 pos;
    vec4 nor;
};

struct Vertex_vvvttnnn {
    vec3 pos;
    vec2 tex;
    vec3 nor;
};

struct AABB {
    vec4 min;
    vec4 max; 
};

struct Triangle {
    AABB aabb;
    Vertex_vvvvnnnn x;
    Vertex_vvvvnnnn y;
    Vertex_vvvvnnnn z;
};

struct FMM_Temp_Node {
    int index;
    FMM_Node node;
};

shared Vertex_vvvvnnnn temp_vertices[BLOCK_SIZE * 3]; 
shared Triangle temp_triangles[BLOCK_SIZE]; 
//++shared Vertex_vvvvnnnn temp_vertices[THREAD_COUNT * 3]; 
//++shared Triangle temp_triangles[THREAD_COUNT]; 

//shared FMM_Node[160] shared_fmm_nodes;
//shared FMM_Node[160*LOCAL_Y_DIM] shared_fmm_nodes;

// Load from application.
shared ivec4[160] shared_offset_table;
shared uint[216] shared_vec_to_offset;

layout(set=0, binding=0) uniform camerauniform {
    mat4 u_view_proj;
    vec4 camera_pos;
};

layout(set = 0, binding = 1) buffer Counters {
    uint[2] atomic_counters;
};

layout(set = 0, binding = 2) buffer Points_out {
    OutputVertex[] output_points;
};

layout(set = 0, binding = 3) buffer FMM_Nodes {
    FMM_Node[] fmm_nodes;
};

layout(set = 0, binding = 4) buffer Triangle_data  {
    Vertex_vvvvnnnn[] triangle_data;
};

//layout(set=0, binding=5, rgba32f) uniform readonly image1D myStorageImage;
//layout(set=0, binding=5, r32f) uniform readonly image1D myStorageImage;
// layout(set = 0, binding = 5) uniform texture1D z1z2_texture;
// layout(set = 0, binding = 6) uniform sampler z1z2_texture_sampler;

layout(set = 0, binding = 5) readonly buffer OffsetTable {
    ivec4[160] offset_hash_table;
};

layout(set = 0, binding = 6) readonly buffer VecToHashTable {
    uint[216] vec_to_offset_table;
};

struct FMM_Attribute {
    uvec3 global_dimensions;
    uint offset_hash_table_size;
    uvec3 current_block;
    uint vec_to_offset_table_size;
};

layout(set=0, binding=7) uniform FMM_Attributes {
    FMM_Attribute fmm_attributes;
};

layout(set=0, binding=8) uniform General_params {
    uvec4 custom_data;
};

layout(local_size_x = LOCAL_X_DIM, local_size_y = LOCAL_Y_DIM, local_size_z = LOCAL_Z_DIM) in;

const float FONT_SIZE = 0.12;
const float FONT_OFFSET_Y = 1.2;
const uint MAX_NUM_OF_POINTS = 150;

//// Super clever hack to avoid if :).
const uint blah[2] = {0, 0xffffffff};

uint local_id_to_x() { return gl_LocalInvocationID.x + LOCAL_X_DIM * gl_LocalInvocationID.y + LOCAL_X_DIM * LOCAL_Z_DIM * gl_LocalInvocationID.z; }


const uint[10] joo = {1,
                      10,
                      100,
                      1000,
                      10000,
                      100000,
                      1000000,
                      10000000,
                      100000000,
                      1000000000};

struct CharInformation {
    uint counter;
    vec3 position;
    uint[MAX_NUM_CHARS] chars;
};

// 2 x float
shared uint[2] counter;

//++// 136 x float
//++// The auxiliar scan block array
//++shared uint shared_aux[SCAN_BLOCK_SIZE];
//++
//++// 136 x float
//++// The output of global active fmm block scan.
//++shared uint[SCAN_BLOCK_SIZE] shared_prefix_sum;
//++
//++//// The counter for active fmm blocks.
//++shared uint stream_compaction_count;

// Debugging.
//shared CharInformation[THREAD_COUNT] char_arrays;
shared CharInformation[1] char_arrays;

const uvec3 local_dimension = uvec3(4,4,4);
const uvec3 group_dimension = uvec3(8,8,8);

const uint bez_indices[17] = {
    104| (108 << 8) | (112 << 16) | (116 << 24),  // 0       
    4  | (8 << 8) | (12 << 16) | (255 << 24),     // 1       
    16 | (20 << 8) | (24 << 16) | (255 << 24),    // 2       
    28 | (32 << 8) | (255 << 16) | (255 << 24),   // 3       
    36 | (40 << 8) | (44 << 16) | (255 << 24),    // 4       
    48 | (52 << 8) | (56 << 16) | (255 << 24),    // 5       
    60 | (64 << 8) | (68 << 16) | (255 << 24),    // 6       
    48 | (72 << 8) | (255 << 16) | (255 << 24),   // 7       
    76 | (80 << 8) | (84 << 16) | (88 << 24),     // 8       
    92 | (96 << 8) | (100 << 16) | (255 << 24),   // 9       
    0  | (255 << 8) | (255 << 16) | (255 << 24),  // 10
    104 | (112 << 8) | (255 << 16) | (255 << 24), // 11
    108 | (116 << 8) | (255 << 16) | (255 << 24), // 12
    148 | (152 << 8) | (156 << 16) | (160 << 24), // 13
    120 | (124 << 8) | (128 << 16) | (132 << 24), // 14
    136 | (140 << 8) | (144 << 16) | (255 << 24), // 15
    255 | (255 << 8) | (255 << 16) | (255 << 24), // 16
};

const vec4 bez_table[164] = {
    // Bez minus. 
    vec4(0.3, 0.5, 0.0, 0.25),     // 0
    vec4(0.433333, 0.5, 0.0, 0.0), // 1
    vec4(0.566666, 0.5, 0.0, 0.0), // 2
    vec4(0.7, 0.5, 0.0, 0.0),      // 3 

    // Bez 1.
    vec4(0.3, 0.1, 0.0, 4.0/14.0), // 4
    vec4(0.433333, 0.1, 0.0, 0.0), // 5
    vec4(0.566666, 0.1, 0.0, 0.0), // 6
    vec4(0.7, 0.1, 0.0, 0.0),      // 7 
    vec4(0.5, 0.1, 0.0, 8.0/14.0), // 8
    vec4(0.5, 0.366666, 0.0, 0.0), // 9
    vec4(0.5, 0.633333, 0.0, 0.0), // 10 
    vec4(0.5, 0.9, 0.0, 0.0),      // 11 
    vec4(0.5, 0.9, 0.0, 2.0/14.0), // 12 
    vec4(0.4, 0.8, 0.0, 0.0),      // 13 
    vec4(0.35, 0.8, 0.0, 0.0),     // 14 
    vec4(0.3, 0.8, 0.0, 0.0),      // 15 

    // Bez 2.
    vec4(0.3, 0.1, 0.0, 5.0/15.0),  // 16 
    vec4(0.433333, 0.1, 0.0, 0.0),  // 17 
    vec4(0.566666, 0.1, 0.0, 0.0),  // 18 
    vec4(0.7, 0.1, 0.0, 0.0),       // 19 
    vec4(0.3, 0.1, 0.0, 5.5/15.0),  // 20 
    vec4(0.416666, 0.3, 0.0, 0.0),  // 21 
    vec4(0.533333, 0.4, 0.0, 0.0),  // 22
    vec4(0.65, 0.55, 0.0, 0.0),     // 23 
    vec4(0.65, 0.55, 0.0, 6.5/15.0),// 24 
    vec4(0.8, 0.7, 0.0, 0.0),       // 25
    vec4(0.55, 1.08, 0.0, 0.0),     // 26
    vec4(0.3, 0.8, 0.0, 0.0),       // 27

    // Number 3
    vec4(0.3, 0.8, 0.0, 0.5),      // 28
    vec4(0.5, 1.1, 0.0, 0.0),      // 29
    vec4(0.95, 0.7, 0.0, 0.0),     // 30
    vec4(0.45, 0.55, 0.0, 0.0),    // 31
    vec4(0.45, 0.55, 0.0, 0.5),    // 32
    vec4(1.0, 0.45, 0.0, 0.0),     // 33
    vec4(0.5, -0.15, 0.0, 0.0),    // 34
    vec4(0.3, 0.2, 0.0, 0.0),      // 35

    // Number 4
    vec4(0.6, 0.1, 0.0, 8.0/17.0),   // 36
    vec4(0.6, 0.3666666, 0.0, 0.0),  // 37
    vec4(0.6, 0.6333333, 0.0, 0.0),  // 38
    vec4(0.6, 0.9, 0.0, 0.0),        // 39
    vec4(0.6, 0.9, 0.0, 5.0/17.0),   // 40
    vec4(0.466666, 0.75, 0.0, 0.0),  // 41
    vec4(0.333333, 0.6, 0.0, 0.0),   // 42
    vec4(0.2, 0.45, 0.0, 0.0),       // 43
    
    vec4(0.2, 0.45, 0.0, 4.0/17.0),  // 44
    vec4(0.3666666, 0.45, 0.0, 0.0), // 45
    vec4(0.5333333, 0.45, 0.0, 0.0), // 46
    vec4(0.7, 0.45, 0.0, 0.0),       // 47
    
    // Number 5.
    vec4(0.3, 0.9, 0.0, 2.0/13.0),  // 48
    vec4(0.433333, 0.9, 0.0, 0.0),  // 49
    vec4(0.566666, 0.9, 0.0, 0.0),  // 50
    vec4(0.7, 0.9, 0.0, 0.0),       // 51
    vec4(0.3, 0.5, 0.0, 2.0/13.0),  // 52
    vec4(0.3, 0.633333, 0.0, 0.0),  // 53
    vec4(0.3, 0.766666, 0.0, 0.0),  // 54
    vec4(0.3, 0.9, 0.0, 0.0),       // 55
    vec4(0.3, 0.5, 0.0, 9.0/13.0),  // 56
    vec4(1.0, 0.75, 0.0, 0.0),      // 57
    vec4(0.7, -0.2, 0.0, 0.0),      // 58
    vec4(0.3, 0.2, 0.0, 0.0),       // 59

    // Number 6
    vec4(0.7, 0.8, 0.0, 5.0/21.0),  // 60
    vec4(0.5, 1.05, 0.0, 0.0),      // 61
    vec4(0.3, 0.8, 0.0, 0.0),       // 62
    vec4(0.3, 0.5, 0.0, 0.0),       // 63
    vec4(0.3, 0.5, 0.0, 9.0/21.0),  // 64
    vec4(0.3, -0.05, 0.0, 0.0),     // 65
    vec4(0.7, 0.0, 0.0, 0.0),       // 66
    vec4(0.72, 0.4, 0.0, 0.0),      // 67
    vec4(0.72, 0.4, 0.0, 5.0/21.0), // 68
    vec4(0.72, 0.6, 0.0, 0.0),      // 69
    vec4(0.5, 0.7, 0.0, 0.0),       // 70
    vec4(0.3, 0.5, 0.0, 0.0),       // 71
    
    // Number 7 .
    // five_bez_a
    vec4(0.4, 0.1, 0.0, 6.0/13.0), // 72
    vec4(0.5, 0.366666, 0.0, 0.0), // 73
    vec4(0.6, 0.633333, 0.0, 0.0), // 74
    vec4(0.7, 0.9, 0.0, 0.0),      // 75
    
    
    // Number 8
    vec4(0.5, 0.9, 0.0, 0.25), // 76
    vec4(0.2, 0.85, 0.0, 0.0), // 77
    vec4(0.2, 0.55, 0.0, 0.0), // 78
    vec4(0.5, 0.5, 0.0, 0.0),  // 79
    vec4(0.5, 0.9, 0.0, 0.25), // 80
    vec4(0.8, 0.85, 0.0, 0.0), // 81
    vec4(0.8, 0.55, 0.0, 0.0), // 82
    vec4(0.5, 0.5, 0.0, 0.0),  // 83
    vec4(0.5, 0.1, 0.0, 0.25), // 84
    vec4(0.8, 0.15, 0.0, 0.0), // 85
    vec4(0.8, 0.45, 0.0, 0.0), // 86
    vec4(0.5, 0.5, 0.0, 0.0),  // 87
    vec4(0.5, 0.1, 0.0, 0.25), // 88
    vec4(0.2, 0.15, 0.0, 0.0), // 89
    vec4(0.2, 0.45, 0.0, 0.0), // 90
    vec4(0.5, 0.5, 0.0, 0.0),  // 91
    
    // Number 9
    vec4(0.3, 0.2, 0.0, 8.0/20.0), // 92
    vec4(0.5, -0.05, 0.0, 0.0),    // 93
    vec4(0.7, 0.2, 0.0, 0.0),      // 94
    vec4(0.7, 0.6, 0.0, 0.0),      // 95
    vec4(0.7, 0.6, 0.0, 6.0/20.0), // 96
    vec4(0.7, 0.95, 0.0, 0.0),     // 97
    vec4(0.4, 1.0, 0.0, 0.0),      // 98
    vec4(0.28, 0.8, 0.0, 0.0),     // 99
    vec4(0.28, 0.8, 0.0, 6.0/20.0),// 100
    vec4(0.1, 0.4, 0.0, 0.0),      // 101
    vec4(0.6, 0.4, 0.0, 0.0),      // 102
    vec4(0.7, 0.6, 0.0, 0.0),      // 103
    
    // Number 0 
    vec4(0.5, 0.9, 0.0, 0.25),   // 104
    vec4(0.25, 0.85, 0.0, 0.0),  // 105
    vec4(0.25, 0.55, 0.0, 0.0),  // 106
    vec4(0.25, 0.5, 0.0, 0.0),   // 107
    vec4(0.5, 0.9, 0.0, 0.25),   // 108
    vec4(0.75, 0.85, 0.0, 0.0),  // 109
    vec4(0.75, 0.55, 0.0, 0.0),  // 110
    vec4(0.75, 0.5, 0.0, 0.0),   // 111
    vec4(0.5, 0.1, 0.0, 0.25),   // 112
    vec4(0.25, 0.15, 0.0, 0.0),  // 113
    vec4(0.25, 0.45, 0.0, 0.0),  // 114
    vec4(0.25, 0.5, 0.0, 0.0),   // 115
    vec4(0.5, 0.1, 0.0, 0.25),   // 116
    vec4(0.75, 0.15, 0.0, 0.0),  // 117
    vec4(0.75, 0.45, 0.0, 0.0),  // 118
    vec4(0.75, 0.5, 0.0, 0.0),   // 119
    
    // Number inf 
    vec4(0.5, 0.5, 0.0, 0.25),   // 120
    vec4(0.4, 0.7, 0.0, 0.0),    // 121
    vec4(0.2, 0.7, 0.0, 0.0),    // 122
    vec4(0.1, 0.5, 0.0, 0.0),    // 123  
    vec4(0.1, 0.5, 0.0, 0.25),   // 124
    vec4(0.2, 0.3, 0.0, 0.0),    // 125
    vec4(0.4, 0.3, 0.0, 0.0),    // 126
    vec4(0.5, 0.5, 0.0, 0.0),    // 127  
    vec4(0.5, 0.5, 0.0, 0.25),   // 128
    vec4(0.6, 0.7, 0.0, 0.0),    // 129
    vec4(0.8, 0.7, 0.0, 0.0),    // 130
    vec4(0.9, 0.5, 0.0, 0.0),    // 131  
    vec4(0.9, 0.5, 0.0, 0.25),   // 132
    vec4(0.8, 0.3, 0.0, 0.0),    // 133
    vec4(0.6, 0.3, 0.0, 0.0),    // 134
    vec4(0.5, 0.5, 0.0, 0.0),    // 135  
    
    // Nan
    vec4(0.2, 0.1, 0.0, 8.0/26.0), // 136
    vec4(0.2, 0.366666, 0.0, 0.0), // 137
    vec4(0.2, 0.633333, 0.0, 0.0), // 138
    vec4(0.2, 0.9, 0.0, 0.0),      // 139
    
    vec4(0.2, 0.9, 0.0, 10.0/26.0),// 140
    vec4(0.4, 0.633333, 0.0, 0.0), // 141
    vec4(0.6, 0.366666, 0.0, 0.0), // 142
    vec4(0.8, 0.1, 0.0, 0.0),      // 143
    
    vec4(0.8, 0.1, 0.0, 8.0/26.0), // 144
    vec4(0.8, 0.366666, 0.0, 0.0), // 145
    vec4(0.8, 0.633333, 0.0, 0.0), // 146
    vec4(0.8, 0.9, 0.0, 0.0),      // 147

    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.5, 0.9, 0.0, 0.15)),   // 148
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.25, 0.85, 0.0, 0.0)),  // 149
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.25, 0.55, 0.0, 0.0)),  // 150
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.25, 0.5, 0.0, 0.0)),   // 151
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.5, 0.9, 0.0, 0.15)),   // 152
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.75, 0.85, 0.0, 0.0)),  // 153
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.75, 0.55, 0.0, 0.0)),  // 154
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.75, 0.5, 0.0, 0.0)),   // 155
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.5, 0.1, 0.0, 0.15)),   // 156
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.25, 0.15, 0.0, 0.0)),  // 157
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.25, 0.45, 0.0, 0.0)),  // 158
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.25, 0.5, 0.0, 0.0)),   // 159
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.5, 0.1, 0.0, 0.15)),   // 160
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.75, 0.15, 0.0, 0.0)),  // 161
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.75, 0.45, 0.0, 0.0)),  // 162
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.75, 0.5, 0.0, 0.0))    // 163
};

float dot2( in vec2 v ) { return dot(v,v); }
float dot2( in vec3 v ) { return dot(v,v); }
float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }

// Triangle - exact
float udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )
{
  vec3 ba = b - a; vec3 pa = p - a;
  vec3 cb = c - b; vec3 pb = p - b;
  vec3 ac = a - c; vec3 pc = p - c;
  vec3 nor = cross( ba, ac );

  return sqrt(
    (sign(dot(cross(ba,nor),pa)) +
     sign(dot(cross(cb,nor),pb)) +
     sign(dot(cross(ac,nor),pc))<2.0)
     ?
     min( min(
     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),
     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),
     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )
     :
     dot(nor,pa)*dot(nor,pa)/dot2(nor) );
}

// Encode vector to "rgba" uint.
uint encode_rgba_u32(uint r, uint g, uint b, uint a) {
  uint col = 0;
  col = (r << 24) | (g << 16) | (b  << 8) | a;
  return col;
}

// Updates counter until MAX_NUM_CHARS is reached.
// Returns the counter value before incrementation. 
uint update_counter() {
    uint local_index = local_id_to_x();
    uint counter_now = char_arrays[local_index].counter;
    char_arrays[local_index].counter = min(counter_now + 1, MAX_NUM_CHARS-1);
    return counter_now;
}

void create_aabb_triangles(AABB aabb, uint r, uint b, uint g) {

    uint aabb_index = atomicAdd(counter[1], 24);

    const vec3 delta = aabb.max.xyz - aabb.min.xyz;
    const vec3 p0 = aabb.min.xyz;
    const vec3 p1 = aabb.min.xyz + vec3(delta.x , 0.0     , 0.0);
    const vec3 p2 = aabb.min.xyz + vec3(delta.x , delta.y , 0.0);
    const vec3 p3 = aabb.min.xyz + vec3(0.0     , delta.y , 0.0);
    const vec3 p4 = aabb.min.xyz + vec3(0.0     , 0.0     , delta.z);
    const vec3 p5 = aabb.min.xyz + vec3(delta.x , 0.0     , delta.z);
    const vec3 p6 = aabb.min.xyz + vec3(delta.x , delta.y , delta.z);
    const vec3 p7 = aabb.min.xyz + vec3(0.0     , delta.y , delta.z);

    OutputVertex p0_out = OutputVertex( p0, encode_rgba_u32(r, g, b, 0));
    OutputVertex p1_out = OutputVertex( p1, encode_rgba_u32(r, g, b, 0));
    OutputVertex p2_out = OutputVertex( p2, encode_rgba_u32(r, g, b, 0));
    OutputVertex p3_out = OutputVertex( p3, encode_rgba_u32(r, g, b, 0));
    OutputVertex p4_out = OutputVertex( p4, encode_rgba_u32(r, g, b, 0));
    OutputVertex p5_out = OutputVertex( p5, encode_rgba_u32(r, g, b, 0));
    OutputVertex p6_out = OutputVertex( p6, encode_rgba_u32(r, g, b, 0));
    OutputVertex p7_out = OutputVertex( p7, encode_rgba_u32(r, g, b, 0));
}


// TODO rename to triangles.
void create_output_points(AABB aabb, uint r, uint g, uint b) {

    uint aabb_index = atomicAdd(counter[1], 36);

    const vec3 delta = aabb.max.xyz - aabb.min.xyz;
    const vec3 p0 = aabb.min.xyz;
    const vec3 p1 = aabb.min.xyz + vec3(delta.x , 0.0     , 0.0);
    const vec3 p2 = aabb.min.xyz + vec3(delta.x , delta.y , 0.0);
    const vec3 p3 = aabb.min.xyz + vec3(0.0     , delta.y , 0.0);
    const vec3 p4 = aabb.min.xyz + vec3(0.0     , 0.0     , delta.z);
    const vec3 p5 = aabb.min.xyz + vec3(delta.x , 0.0     , delta.z);
    const vec3 p6 = aabb.min.xyz + vec3(delta.x , delta.y , delta.z);
    const vec3 p7 = aabb.min.xyz + vec3(0.0     , delta.y , delta.z);

    // FRONT.

    const float lf_factor = 0.3;
    const uint lfr = uint(r*lf_factor);
    const uint lfg = uint(g*lf_factor);
    const uint lfb = uint(b*lf_factor);

    output_points[aabb_index]   = OutputVertex(p6, encode_rgba_u32(lfr, lfg, lfb, 1)); 
    output_points[aabb_index+1] = OutputVertex(p7, encode_rgba_u32(lfr, lfg, lfb, 1)); 
    output_points[aabb_index+2] = OutputVertex(p4, encode_rgba_u32(lfr, lfg, lfb, 1)); 

    output_points[aabb_index+3] = OutputVertex(p4, encode_rgba_u32(lfr, lfg, lfb, 1)); 
    output_points[aabb_index+4] = OutputVertex(p5, encode_rgba_u32(lfr, lfg, lfb, 1)); 
    output_points[aabb_index+5] = OutputVertex(p6, encode_rgba_u32(lfr, lfg, lfb, 1)); 

    // RIGHT.

    const float lr_factor = 0.6;
    const uint lrr = uint(r*lr_factor);
    const uint lrg = uint(g*lr_factor);
    const uint lrb = uint(b*lr_factor);

    output_points[aabb_index+6] = OutputVertex(p5, encode_rgba_u32(lrr, lrg, lrb, 1)); 
    output_points[aabb_index+7] = OutputVertex(p1, encode_rgba_u32(lrr, lrg, lrb, 1)); 
    output_points[aabb_index+8] = OutputVertex(p2, encode_rgba_u32(lrr, lrg, lrb, 1)); 

    output_points[aabb_index+9]  = OutputVertex(p2, encode_rgba_u32(lrr, lrg, lrb, 1)); 
    output_points[aabb_index+10] = OutputVertex(p6, encode_rgba_u32(lrr, lrg, lrb, 1)); 
    output_points[aabb_index+11] = OutputVertex(p5, encode_rgba_u32(lrr, lrg, lrb, 1)); 

    // BACK.

    output_points[aabb_index+12] = OutputVertex(p2, encode_rgba_u32(r, g, b, 1)); 
    output_points[aabb_index+13] = OutputVertex(p1, encode_rgba_u32(r, g, b, 1)); 
    output_points[aabb_index+14] = OutputVertex(p0, encode_rgba_u32(r, g, b, 1)); 

    output_points[aabb_index+15] = OutputVertex(p3, encode_rgba_u32(r, g, b, 1)); 
    output_points[aabb_index+16] = OutputVertex(p2, encode_rgba_u32(r, g, b, 1)); 
    output_points[aabb_index+17] = OutputVertex(p0, encode_rgba_u32(r, g, b, 1)); 

    // LEFT.

    const float ll_factor = 0.6;
    const uint llr = uint(r*ll_factor);
    const uint llg = uint(g*ll_factor);
    const uint llb = uint(b*ll_factor);

    output_points[aabb_index+18] = OutputVertex(p7, encode_rgba_u32(llr, llg, llb, 1)); 
    output_points[aabb_index+19] = OutputVertex(p3, encode_rgba_u32(llr, llg, llb, 1)); 
    output_points[aabb_index+20] = OutputVertex(p0, encode_rgba_u32(llr, llg, llb, 1)); 

    output_points[aabb_index+21] = OutputVertex(p0, encode_rgba_u32(llr, llg, llb, 1)); 
    output_points[aabb_index+22] = OutputVertex(p4, encode_rgba_u32(llr, llg, llb, 1)); 
    output_points[aabb_index+23] = OutputVertex(p7, encode_rgba_u32(llr, llg, llb, 1)); 

    // TOP.

    const float lt_factor = 0.8;
    const uint ltr = uint(r*lt_factor);
    const uint ltg = uint(g*lt_factor);
    const uint ltb = uint(b*lt_factor);

    output_points[aabb_index+24] = OutputVertex(p7, encode_rgba_u32(ltr, ltg, ltb, 1)); 
    output_points[aabb_index+25] = OutputVertex(p6, encode_rgba_u32(ltr, ltg, ltb, 1)); 
    output_points[aabb_index+26] = OutputVertex(p2, encode_rgba_u32(ltr, ltg, ltb, 1)); 

    output_points[aabb_index+27] = OutputVertex(p2, encode_rgba_u32(ltr, ltg, ltb, 1)); 
    output_points[aabb_index+28] = OutputVertex(p3, encode_rgba_u32(ltr, ltg, ltb, 1)); 
    output_points[aabb_index+29] = OutputVertex(p7, encode_rgba_u32(ltr, ltg, ltb, 1)); 

    // BOTTOM.

    const float lb_factor = 0.15;
    const uint lbr = uint(r*lb_factor);
    const uint lbg = uint(g*lb_factor);
    const uint lbb = uint(b*lb_factor);

    output_points[aabb_index+30] = OutputVertex(p1, encode_rgba_u32(lbr, lbg, lbb, 1)); 
    output_points[aabb_index+31] = OutputVertex(p5, encode_rgba_u32(lbr, lbg, lbb, 1)); 
    output_points[aabb_index+32] = OutputVertex(p4, encode_rgba_u32(lbr, lbg, lbb, 1)); 

    output_points[aabb_index+33] = OutputVertex(p4, encode_rgba_u32(lbr, lbg, lbb, 1)); 
    output_points[aabb_index+34] = OutputVertex(p0, encode_rgba_u32(lbr, lbg, lbb, 1)); 
    output_points[aabb_index+35] = OutputVertex(p1, encode_rgba_u32(lbr, lbg, lbb, 1)); 
}

void create_aabb_triangles_r(AABB aabb, uint r, uint g, uint b, float t) {
    AABB back_bottom = AABB(aabb.min, vec4(aabb.max.x, aabb.min.y + t, aabb.min.z + t, 1.0));
    AABB right_bottom = AABB(aabb.min, vec4(aabb.min.x + t, aabb.min.y + t, aabb.max.z, 1.0));
    AABB left_bottom = AABB(vec4(aabb.max.x - t, aabb.min.y, aabb.min.z, 1.0),
                            vec4(aabb.max.x, aabb.min.y + t, aabb.max.z, 1.0));
    AABB front_bottom = AABB(vec4(aabb.min.x, aabb.min.y, aabb.max.z - t, 1.0),
                             vec4(aabb.max.x, aabb.min.y + t, aabb.max.z, 1.0));

    AABB back_top = AABB(vec4(aabb.min.x, aabb.max.y - t, aabb.min.z, 1.0),  
                         vec4(aabb.max.x, aabb.max.y,     aabb.min.z + t, 1.0));
    AABB left_top = AABB(vec4(aabb.min.x,     aabb.max.y - t, aabb.min.z, 1.0),  
                          vec4(aabb.min.x + t, aabb.max.y,     aabb.max.z, 1.0));
    AABB right_top = AABB(vec4(aabb.max.x - t, aabb.max.y - t, aabb.min.z, 1.0),  
                          vec4(aabb.max.x,     aabb.max.y,     aabb.max.z, 1.0));
    AABB front_top = AABB(vec4(aabb.min.x,     aabb.max.y - t, aabb.max.z - t, 1.0),  
                          vec4(aabb.max.x,     aabb.max.y,     aabb.max.z, 1.0));
    AABB back_left_ud = AABB(vec4(aabb.min.x,     aabb.min.y, aabb.min.z, 1.0),  
                             vec4(aabb.min.x + t, aabb.max.y, aabb.min.z + t, 1.0));
    AABB back_right_ud = AABB(vec4(aabb.max.x - t, aabb.min.y, aabb.min.z, 1.0),  
                              vec4(aabb.max.x    , aabb.max.y, aabb.min.z + t, 1.0));
    AABB front_right_ud = AABB(vec4(aabb.min.x,    aabb.min.y, aabb.max.z - t, 1.0),  
                              vec4(aabb.min.x + t, aabb.max.y, aabb.max.z, 1.0));
    AABB front_left_ud = AABB(vec4(aabb.max.x - t, aabb.min.y, aabb.max.z - t, 1.0),  
                              vec4(aabb.max.x    , aabb.max.y, aabb.max.z, 1.0));
    create_output_points(back_bottom, r, g, b); 
    create_output_points(right_bottom, r, g, b); 
    create_output_points(left_bottom, r, g, b); 
    create_output_points(front_bottom, r, g, b); 
    create_output_points(back_top, r, g, b); 
    create_output_points(left_top, r, g, b); 
    create_output_points(right_top, r, g, b); 
    create_output_points(front_top, r, g, b); 
    create_output_points(back_left_ud, r, g, b); 
    create_output_points(back_right_ud, r, g, b); 
    create_output_points(front_right_ud, r, g, b); 
    create_output_points(front_left_ud, r, g, b); 
}


void bezier_4c(uint n, vec4 c0, vec4 c1, vec4 c2, vec4 c3, uint r, uint g, uint b) {

    if (n < 4) return;

    uint index = atomicAdd(counter[0], n);

    for (int i=0 ; i<n ; i++) {
        const float t = float(i)  / (float(n)-1.0);
        const float t2 = t * t;
        const float t3 = t2 * t;
        const float mt = 1.0 - t;
        const float mt2 = mt * mt;
        const float mt3 = mt2 * mt;
        const vec3 result = c0.xyz * mt3 + c1.xyz * 3.0 * mt2*t + c2.xyz * 3.0 * mt*t2 + c3.xyz * t3;
        const float dist = min(max(1.0, distance(camera_pos.xyz, result)), 255);
        output_points[index] = OutputVertex(
            result,
            encode_rgba_u32(
                r,
                g,
                b,
                uint(dist)));
        index++;
    }
}

void create_array(float array_width, vec3 base_pos, vec3 dest_pos, uint r, uint g, uint b) {

    vec3 array_direction = normalize(dest_pos - base_pos);
    vec3 camera_direction = normalize(camera_pos.xyz - base_pos);

    // Array length.
    float array_length = distance(dest_pos, base_pos);
    float array_base_length = array_length - array_width;

    vec3 side_direction = cross(camera_direction, array_direction);   

    uint index = atomicAdd(counter[1], 21);

    const vec3 p0 = base_pos;
    const vec3 p1 = base_pos + side_direction * array_width;
    const vec3 p2 = base_pos - side_direction * array_width;
    const vec3 p3 = p1 + array_direction * array_base_length;
    const vec3 p4 = p2 + array_direction * array_base_length;
    const vec3 p5 = base_pos + array_direction * array_base_length;
    const vec3 p6 = dest_pos;
    const vec3 p7 = p3 + side_direction * array_width * 2.0;
    const vec3 p8 = p4 - side_direction * array_width * 2.0;

    output_points[index]   = OutputVertex(p1, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+1] = OutputVertex(p0, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+2] = OutputVertex(p3, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+3] = OutputVertex(p0, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+4] = OutputVertex(p5, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+5] = OutputVertex(p3, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+6] = OutputVertex(p0, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+7] = OutputVertex(p2, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+8] = OutputVertex(p4, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+9] = OutputVertex(p4, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+10] = OutputVertex(p5, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+11] = OutputVertex(p0, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+12] = OutputVertex(p3, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+13] = OutputVertex(p4, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+14] = OutputVertex(p6, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+15] = OutputVertex(p3, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+16] = OutputVertex(p6, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+17] = OutputVertex(p7, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+18] = OutputVertex(p4, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+19] = OutputVertex(p8, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+20] = OutputVertex(p6, encode_rgba_u32(r, g, b, 1)); 
}

uint get_remainder(uint num, uint divisor) {
    return (num - divisor * (num / divisor));
}

void log_number(uint n, bool ignore_first) {
       // 4294967295 
       // 1000000000
    uint local_index = local_id_to_x();

    bool found = false;
    bool ignore = ignore_first;
    uint temp_n = n;

    if (n == 0) {
        char_arrays[local_index].chars[update_counter()] = 0;
        return;
    }

    for (int i=9 ; i>=0 ; i--) {
        uint remainder = temp_n / joo[i];  
        temp_n -= remainder * joo[i];
        if (remainder != 0) {
            found = true;	    
        }
        if (found == true) {
            if (ignore == true) { ignore = false; continue; }
            char_arrays[local_index].chars[update_counter()] = remainder; 
        }
    }
}

void create_char(uint char_index, uint num_points, vec4 offset, uint r, uint g, uint b) {

    uint index = bez_indices[char_index];

    uint indices[4] = {
        index & 0xff,
        (index & 0xff00) >> 8,
        (index & 0xff0000) >> 16,
        (index & 0xff000000) >> 24,
    };

    for (uint i=0 ; i<4 ; i++) {
        uint bez_index = indices[i];
        if (bez_index == 255) break;
        vec4 bi = bez_table[bez_index];
        uint count = uint(max(1.0, num_points * bi.w));
        bezier_4c(
            count,
            FONT_SIZE * bez_table[bez_index + 0] + offset,
            FONT_SIZE * bez_table[bez_index + 1] + offset,
            FONT_SIZE * bez_table[bez_index + 2] + offset,
            FONT_SIZE * bez_table[bez_index + 3] + offset,
            r,
            g,
            b
        );
    }
}

void log_float(double f, uint max_decimals) {

    uint local_index = local_id_to_x();
    //uint counter_now = counter;

    // The sign of given float.
    bool is_negative = f < 0.0;

    // Add minus.
    if (is_negative) {
        char_arrays[local_index].chars[update_counter()] = 10;
        //char_arrays[local_index].counter++;
    }

    double f_positive = abs(f);

    // The integer part.
    float integer_temp; 

    // The fractional component.
    double _f_part = modf(float(f_positive), integer_temp);

    double f_part = fract(f_positive);

    // Multiply fractional part so it becomes uint.
    uint fract_part = uint((f_part+1.0)*joo[max_decimals]); //pow(10.0, max_decimals));

    // Cast integer part to uint.
    uint integer_part = uint(abs(integer_temp));

    // Parse the integer part.
    log_number(integer_part, false);

    // Add dot.
    char_arrays[local_index].chars[update_counter()] = 13;

    // Parse the frag part.
    log_number(fract_part, true);
}

void log_uvec3(uvec3 v) {

    uint local_index = local_id_to_x();

    // Add left paren.
    char_arrays[local_index].chars[update_counter()] = 11;

    log_number(v.x, false);

    // Add space x 2.
    char_arrays[local_index].chars[update_counter()] = 16;
    char_arrays[local_index].chars[update_counter()] = 16;

    log_number(v.y, false);

    // Add space x 2.
    char_arrays[local_index].chars[update_counter()] = 16;
    char_arrays[local_index].chars[update_counter()] = 16;

    log_number(v.z, false);
    
    // Add right paren.
    char_arrays[local_index].chars[update_counter()] = 12;

}

void log_vec3(vec3 v, uint max_decimals) {
    
    uint local_index = local_id_to_x();

    // Add left paren.
    char_arrays[local_index].chars[update_counter()] = 11;

    log_float(double(v.x), 7);

    // Add space x 2.
    char_arrays[local_index].chars[update_counter()] = 16;
    char_arrays[local_index].chars[update_counter()] = 16;

    log_float(double(v.y), 7);

    // Add space x 2.
    char_arrays[local_index].chars[update_counter()] = 16;
    char_arrays[local_index].chars[update_counter()] = 16;

    log_float(double(v.z), 7);
    
    // Add right paren.
    char_arrays[local_index].chars[update_counter()] = 12;
}

AABB create_char_sequency_points(uint r, uint g, uint b) {

    uint local_index = local_id_to_x();
    vec3 base_vector = char_arrays[local_index].position;
    const float dist = distance(base_vector, camera_pos.xyz);
    uint average_points_per_char = max(4, uint(min(MAX_NUM_OF_POINTS, MAX_NUM_OF_POINTS / pow(dist, 2.0)))); 
    vec4 local_offset = vec4(base_vector, 0.0);
    uint number_of_lines = 0;
    uint max_text_width = 0;
    uint text_width = 0;
      
    for (uint i=0; i<char_arrays[local_index].counter; i++) {
        uint numb = char_arrays[local_index].chars[i];

        // end of line.
        if (numb == 17) {
            number_of_lines++;
            local_offset = vec4(base_vector, 0.0) + vec4(0.0, (-FONT_OFFSET_Y) * float(number_of_lines) * FONT_SIZE, 0.0, 0.0);
            if (text_width > max_text_width) {
                max_text_width = text_width;
                text_width = 0;
            }
        }
        else {
            create_char(numb, average_points_per_char, local_offset, r, g, b);
            local_offset = local_offset + vec4(FONT_SIZE * 0.7, 0.0, 0.0, 0.0);
            text_width++;
        }
    }

    AABB aabb = AABB(
      vec4(base_vector, 0.0) + vec4(-0.5 * FONT_SIZE, number_of_lines * (-FONT_OFFSET_Y - 0.1) * FONT_SIZE, -0.05, 0.0),
      vec4(base_vector, 0.0) + FONT_SIZE * vec4(max_text_width * 0.8, FONT_OFFSET_Y, 0.0, 0.0) + vec4(0.0,0.0,-0.001,0.0)
    );
    return aabb;
}

void add_end_of_line() {
    uint local_index = local_id_to_x();
    char_arrays[local_index].chars[char_arrays[local_index].counter] = 17;
    char_arrays[local_index].counter++;
}

void initialize_char_array(vec3 position) {

    uint local_index = local_id_to_x();

    char_arrays[local_index].counter = 0;
    char_arrays[local_index].position = position;
}

uint block_coord_to_block_index(uvec3 coord) {
  uint block_index = coord.x +
                     coord.y * 4 +
                     coord.z * 16;
  return block_index;
}

// For given block index,
uvec3 work_x_index_to_uvec3(uint work_index) {
  //uint work_index = gl_WorkGroupID.x;
  uint index = work_index;
  uint wh = group_dimension.x * group_dimension.y;
  uint z = index / wh;
  index -= z * wh;
  uint y = index / group_dimension.x;
  index -= y * group_dimension.x;
  uint x = index;
  return uvec3(x, y, z);
}

void push_chars(uint r, uint g, uint b) {

  uint local_index = local_id_to_x();
  vec3 original_coord = char_arrays[local_index].position;

  AABB aabb = create_char_sequency_points(255, 125, 125);
  AABB traslated = AABB(vec4(original_coord, 1.0), vec4(original_coord + vec3(1.0, 1.0, 1.0), 1.0));
  create_output_points(aabb,
                    r,
                    g,
                    b
                    );
}

vec3 closest_point_to_triangle(vec3 p, vec3 a, vec3 b, vec3 c) {

    vec3 ab = b - a;
    vec3 ac = c - a;
    vec3 bc = c - b;

    float d1 = dot(b-a, p-a);
    float d2 = dot(c-a, p-a);
    float d3 = dot(b-a, p-b);
    float d4 = dot(c-a, p-b);
    float d5 = dot(b-a, p-c);
    float d6 = dot(c-a, p-c);

    float va = d3*d6 - d5*d4;
    float vb = d5*d2 - d1*d6;
    float vc = d1*d4 - d3*d2;

    float snom = d1;
    float sdenom = -d3;
    float tnom = d2;
    float tdenom = -d6;
    float unom = d4 - d3;
    float udenom = d5 - d6;

    if (snom <= 0.0 && tnom <= 0.0) { return a; }
    if (sdenom <= 0.0 && unom <= 0.0) { return b; }
    if (tdenom <= 0.0 && udenom <= 0.0) { return c; }

    vec3 n = cross(b-a, c-a);

    if (vc <= 0.0 && snom >= 0.0 && sdenom >= 0.0) { return a + snom / (snom + sdenom) * ab; }
    if (va <= 0.0 && unom >= 0.0 && udenom >= 0.0) { return b + unom / (unom + udenom) * bc; }
    if (vb <= 0.0 && tnom >= 0.0 && tdenom >= 0.0) { return a + tnom / (tnom + tdenom) * ac; }

    float u = va / (va + vb + vc);
    float v = vb / (va + vb + vc);
    float w = 1.0 - u - v;
    return u * a + v * b + w * c;
}

// Calculate uvec3 from given index and dimensions.
uvec3 index_to_uvec3(uint the_index, uint dim_x, uint dim_y) {
  uint index = the_index;
  uint wh = dim_x * dim_y;
  uint z = index / wh;
  index -= z * wh;
  uint y = index / dim_x;
  index -= y * dim_x;
  uint x = index;
  return uvec3(x, y, z);
}

void add_triangle() {

    // Load triangle.
    const Vertex_vvvvnnnn vert_x = temp_vertices[3*gl_LocalInvocationIndex];
    const Vertex_vvvvnnnn vert_y = temp_vertices[3*gl_LocalInvocationIndex+1];
    const Vertex_vvvvnnnn vert_z = temp_vertices[3*gl_LocalInvocationIndex+2]; 
    
    // Calculate aabb.
    
    const float aabb_min_x = min(vert_z.pos.x, min(vert_x.pos.x, vert_y.pos.x));
    const float aabb_min_y = min(vert_z.pos.y, min(vert_x.pos.y, vert_y.pos.y));
    const float aabb_min_z = min(vert_z.pos.z, min(vert_x.pos.z, vert_y.pos.z));
    
    const float aabb_max_x = max(vert_z.pos.x, max(vert_x.pos.x, vert_y.pos.x));
    const float aabb_max_y = max(vert_z.pos.y, max(vert_x.pos.y, vert_y.pos.y));
    const float aabb_max_z = max(vert_z.pos.z, max(vert_x.pos.z, vert_y.pos.z));
    
    // Calculate extended aabb.
    const int min_x_expanded = int(min(float(fmm_attributes.global_dimensions.x), max(0.0, floor(aabb_min_x*0.25))));
    const int min_y_expanded = int(min(float(fmm_attributes.global_dimensions.y), max(0.0, floor(aabb_min_y*0.25))));
    const int min_z_expanded = int(min(float(fmm_attributes.global_dimensions.z), max(0.0, floor(aabb_min_z*0.25))));
    
    const int max_x_expanded = int(
        min(float(fmm_attributes.global_dimensions.x), max(0.0, ceil((aabb_max_x+1)*0.25)))
    );
    const int max_y_expanded = int(
        min(float(fmm_attributes.global_dimensions.y), max(0.0, ceil((aabb_max_y+1)*0.25)))
    );
    const int max_z_expanded = int(
        min(float(fmm_attributes.global_dimensions.z), max(0.0, ceil((aabb_max_z+1)*0.25)))
    );
    
    // Add found triangle to shared memory.
    temp_triangles[gl_LocalInvocationIndex] =
        Triangle(
            AABB(vec4(min_x_expanded, min_y_expanded, min_z_expanded, 1.0), vec4(max_x_expanded, max_y_expanded, max_z_expanded, 1.0)), 
            vert_x,
            vert_y,
            vert_z
        );
}

void apply_triangle_mesh() {

  // Total number of triangles.
  const uint triangle_count = custom_data.x;
  const uint vertex_count = custom_data.x*3;

  // The number of triangle blocks divided among the all threads.
  //++const uint number_of_triangle_blocks = (triangle_count - 1) / THREAD_COUNT + 1;
  const uint number_of_triangle_blocks = (triangle_count - 1) / BLOCK_SIZE + 1;
  
  // PLAN.
  // 1. Load triangle data in blocks to the shared memory.
  // 2. Calculate expanded aabbs. Expanded mean that the aabb is extended to
  //    the nearest fmm grids.
  // 3. For each triangle, compute the distance values.
  // 4. Go back to 1. if there are still unprocessed data.

  // The number of unprocessed triangles.
  uint items_available = triangle_count;

  for (int i=0 ; i<number_of_triangle_blocks ; i++) {

    uint thread_id = i * 3 * BLOCK_SIZE + gl_LocalInvocationIndex;
    
    //    0         64        128       192      256       320       384       ....  (triangle_data 'Global') 
    //    +---------+---------+---------+---------+---------+---------+---------+---------+
    //    |         |         |         |         |         |         |         |         |
    //    +---------+---------+---------+---------+---------+---------+---------+---------+
    //        ^         ^         ^           ^         ^         ^                             
    //        |         |         |           |         |         |                              
    //        a0        b0        c0          a1        b2        c1                             
    //

    // Load triangle vertices to shared memory.
    if (gl_LocalInvocationIndex < BLOCK_SIZE) { 
        temp_vertices[gl_LocalInvocationIndex] = thread_id < vertex_count ? triangle_data[thread_id] : Vertex_vvvvnnnn(vec4(0.0), vec4(0.0));
        temp_vertices[gl_LocalInvocationIndex + BLOCK_SIZE] = thread_id < vertex_count ? triangle_data[thread_id + BLOCK_SIZE] : Vertex_vvvvnnnn(vec4(0.0), vec4(0.0));
        temp_vertices[gl_LocalInvocationIndex + BLOCK_SIZE * 2] = thread_id < vertex_count ? triangle_data[thread_id + BLOCK_SIZE * 2] : Vertex_vvvvnnnn(vec4(0.0), vec4(0.0));
    }

    barrier();

    //    0         64        128      192  (temp_vertices 'shared')                                        
    //    +---------+---------+---------+                                                  
    //    |         |         |         |                                                  
    //    +---------+---------+---------+                                                  
    //        ^^^                                                                               
    //        |||                                                                                
    //        xyz                                                                                

    // Determine the count of items in this iteration.
    uint number_of_taken_items = min(BLOCK_SIZE, items_available);

    // Decrease the number of available items.
    items_available -= number_of_taken_items;

    // If there are still unprocessed triangles (not out of context).
    if (gl_LocalInvocationIndex < number_of_taken_items) {
        if (gl_LocalInvocationIndex < BLOCK_SIZE) { 
            add_triangle();
        }
    }

    // Make sure all triangle are stored.
    //groupMemoryBarrier();
    barrier();

    // Iterate over all shared memory triangles. All fmm blocks that are inside
    // aabb are processed. FMM block values are update if necessery.
    for (int triangle_index=0 ; triangle_index < number_of_taken_items ; triangle_index++) {
        barrier(); // necessery? Most likely yes.

        Triangle temp_triangle = temp_triangles[triangle_index];

        uint dim_x_min = uint(temp_triangle.aabb.min.x);
        uint dim_y_min = uint(temp_triangle.aabb.min.y);
        uint dim_z_min = uint(temp_triangle.aabb.min.z);
        uint dim_x_max = uint(temp_triangle.aabb.max.x);
        uint dim_y_max = uint(temp_triangle.aabb.max.y);
        uint dim_z_max = uint(temp_triangle.aabb.max.z);

        // Triangle is atleast partly inside computation domain.
        if (!(dim_x_max == 0 || dim_x_min >= fmm_attributes.global_dimensions.x ||
              dim_y_max == 0 || dim_y_min >= fmm_attributes.global_dimensions.y ||
              dim_z_max == 0 || dim_z_min >= fmm_attributes.global_dimensions.z)) { 

            uint delta_x = dim_x_max - dim_x_min; 
            uint delta_y = dim_y_max - dim_y_min; 
            uint delta_z = dim_z_max - dim_z_min; 

            uint xyz_count = delta_x * delta_y * delta_z;

            //const uint offset = uint(ceil(xyz_count/LOCAL_Y_DIM));
            //const uint offset = uint(xyz_count/LOCAL_Y_DIM + 1);

            //for (uint ind = 0 ; ind<offset ; ind++) {
            for (uint ind = 0 ; ind<xyz_count ; ind = ind + LOCAL_Y_DIM) {

                //uint actual_index = ind + offset * gl_LocalInvocationID.y;
                uint actual_index = ind + gl_LocalInvocationID.y;
                if (actual_index >= xyz_count) break;

                uvec3 local_ind = index_to_uvec3(actual_index, delta_x, delta_y);
                uvec3 transformed_ind = uvec3(dim_x_min + local_ind.x, dim_y_min + local_ind.y, dim_z_min + local_ind.z);

                // Calculate the base index offset for the current FMM block.
                const uint base_index = transformed_ind.x * 64 +
                                        transformed_ind.y * 64 * fmm_attributes.global_dimensions.x +
                                        transformed_ind.z * 64 * fmm_attributes.global_dimensions.x * fmm_attributes.global_dimensions.y;

                // Load local offset information.
                //ivec4 pos_and_offset = shared_offset_table[gl_LocalInvocationIndex];
                ivec4 pos_and_offset = shared_offset_table[gl_LocalInvocationID.x];
                
                // Load FMM node.
                FMM_Node node = fmm_nodes[base_index + pos_and_offset.w];

                ivec3 this_coord = pos_and_offset.xyz + (ivec3(transformed_ind.x, transformed_ind.y, transformed_ind.z) * 4);

                vec3 closest = closest_point_to_triangle(
                    this_coord,
                    temp_triangle.x.pos.xyz,
                    temp_triangle.y.pos.xyz,
                    temp_triangle.z.pos.xyz
                );

                float dist = distance(closest, this_coord);

                vec3 normal = normalize(
                    cross(
                        temp_triangle.y.pos.xyz - temp_triangle.x.pos.xyz,
                        temp_triangle.z.pos.xyz - temp_triangle.x.pos.xyz
                    )
                );

                float pah = dot(normal, closest - this_coord);
                if (pah >= 0.0) { dist = -dist; }

                if (abs(dist) < 1.0) {

                    node.tag = KNOWN;
                    // Update node value if a smaller distance if found.
                    node.value = abs(dist) < abs(node.value) ? abs(dist) : node.value;
                    //node.value = abs(dist) < abs(node.value) ? dist : node.value;

                    // Save updated fmm node.
                    fmm_nodes[base_index + pos_and_offset.w] = node;
                }
              } // for
        } // if
    } // for
  }
}

void copy_offset_to_shared(uint thread_id) {
    shared_offset_table[thread_id] = offset_hash_table[thread_id];
}

void copy_vec_to_offset_to_shared(uint thread_id) {
    shared_vec_to_offset[thread_id] = vec_to_offset_table[thread_id];
}

//++ // Calculate from local coordinate to local shared index (map from local indes
//++ // to local index hash map value.
//++ // Prerequisites: shared_vec_to_offset must be initialized before using this function.
//++ uint get_transformed_index(ivec3 position) {
//++     const ivec3 transformed_position = position + ivec3(1,1,1);
//++     const uint position_index = transformed_position.x + transformed_position.y * 6 + transformed_position.z * 36;
//++     return shared_vec_to_offset[position_index];
//++ }

// Loads offset hash table to shared memory.
void load_offset_hash_table() {

  const uint number_of_threads = LOCAL_X_DIM * LOCAL_Y_DIM;  
  const uint number_of_offset_blocks = (fmm_attributes.offset_hash_table_size - 1) / number_of_threads + 1;

  for (int j=0 ; j < number_of_offset_blocks ; j++) {
      const uint thread_id = j * number_of_threads + gl_LocalInvocationIndex;
      if (thread_id >= fmm_attributes.offset_hash_table_size) break;
      copy_offset_to_shared(thread_id);
  }
}

// Loads vec to offset hash table to shared memory.
void load_vec_to_offset() {

  const uint number_of_threads = LOCAL_X_DIM * LOCAL_Y_DIM;  
  const uint number_of_vec_to_offset_blocks = (fmm_attributes.vec_to_offset_table_size - 1) / number_of_threads + 1;

  for (int j=0 ; j < number_of_vec_to_offset_blocks ; j++) {

      const uint thread_id = j * number_of_threads + gl_LocalInvocationIndex;
      if (thread_id >= fmm_attributes.vec_to_offset_table_size) break;
      copy_vec_to_offset_to_shared(thread_id);
  }
}

void main() {

  if (local_id_to_x() == 0) {
    counter[0] = atomic_counters[0];
    counter[1] = atomic_counters[1];
  }

  // Load hash tables for fmm indexing.

  load_offset_hash_table();
  load_vec_to_offset();
  barrier();

  apply_triangle_mesh();
  barrier();

  if (local_id_to_x() == 0) {
    atomic_counters[0] = counter[0];
    atomic_counters[1] = counter[1];
  }
}

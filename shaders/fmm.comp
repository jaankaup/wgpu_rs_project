// NOTES:TODO
// Create blocks in kernel.

#version 450

#define MAX_NUM_CHARS 16 

#define LOCAL_X_DIM 64 
#define LOCAL_Y_DIM 4 
#define LOCAL_Z_DIM 1
#define THREAD_COUNT (LOCAL_X_DIM * LOCAL_Y_DIM * LOCAL_Z_DIM)
#define SCAN_BLOCK_SIZE (THREAD_COUNT * 2 + ((THREAD_COUNT * 2) >> 4))

#define FAR 2
#define BAND 1
#define KNOWN 0
//#define KNOWN_NEW 1
//#define NEW_BAND 2

//   0   1   2   3   4   5   6   0   1   2   3   4   5   6   0   1   2   3   4   5   6   7  .. 
// +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
// |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
// +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

shared uint[THREAD_COUNT] thread_check_table;

// Fast marching method cell node.
// 0 => Far.
// 1 => Band.
// 2 => Known.
// 3 => Band unknow.
// 5 => Out of context.
struct FMM_Node {
    float value;
    uint tag;
};

struct BlockData {
    ivec3 base_position;
    uint base_index;
};

struct Block_Band_Info {
    uint tag; // 0 :: Center, 1 :: Back, 2 :: Front, 4 :: Right, 8 :: Left, 16 :: Top, 32 :: Bottom 
    bool has_band;
};

struct FMM_Block_Shared {
    uint tag;          // Node tag.
    uint global_index; // Node index.
    int block_index;   // Block index.
    ivec3 global_pos;
};

/* Data integrity/synchronization */
shared uint shared_changed_fmm_counter;
shared FMM_Block_Shared[8 * LOCAL_Y_DIM] shared_changed_fmm_info;
//shared BlockData[LOCAL_Y_DIM] shared_block_sync_info; // not used.

shared FMM_Node[160*LOCAL_Y_DIM] shared_fmm_nodes;
shared uint[THREAD_COUNT] shared_fmm_indices;
shared uint[LOCAL_Y_DIM] band_counts;

// Load from application.
shared ivec4[160] shared_offset_table;
shared uint[216] shared_vec_to_offset;

#define DEBUG_OFFSET 0.07

struct FMM_Block {
    uint index;
    uint band_points_count;
};

struct OutputVertex {
    vec3 pos;
    uint color_point_size;
};

struct AABB {
    vec4 min;
    vec4 max; 
};

layout(set=0, binding=0) uniform camerauniform {
    mat4 u_view_proj;
    vec4 camera_pos;
};

// This buffer holds the temporary prefix sum data.
layout(set = 0, binding = 1) buffer Prefix_sums {
    uint[] temp_prefix_sum;
};

layout(set = 0, binding = 2) buffer Points_out {
    OutputVertex[] output_points;
};

layout(set = 0, binding = 3) buffer FMM_Nodes {
    FMM_Node[] fmm_nodes;
};

// This buffer is divided to two parts.
// The first part includes the actual FMM_Blocks.
// The second part includes the active FMM_Blocks.
layout(set = 0, binding = 4) buffer FMM_Blocks {
    FMM_Block[] fmm_block;
};

layout(set = 0, binding = 5) buffer Counters {
    uint[2] atomic_counters;
};

layout(set = 0, binding = 6) readonly buffer OffsetTable {
    ivec4[160] offset_hash_table;
};

layout(set = 0, binding = 7) readonly buffer VecToHashTable {
    uint[216] vec_to_offset_table;
};

struct FMM_Attribute {
    uvec3 global_dimensions;
    uint offset_hash_table_size;
    uvec3 current_block;
    uint vec_to_offset_table_size;
};

layout(set=0, binding=8) uniform FMM_Attributes {
    FMM_Attribute fmm_attributes;
};

layout(local_size_x = LOCAL_X_DIM, local_size_y = LOCAL_Y_DIM, local_size_z = LOCAL_Z_DIM) in;

const float FONT_SIZE = 0.06;
const float FONT_OFFSET_Y = 1.2;
const uint MAX_NUM_OF_POINTS = 150;

//// Super clever hack to avoid if :).
const uint blah[2] = {0, 0xffffffff};

uint local_id_to_x() { return gl_LocalInvocationIndex; }

struct Thread_id_info {
    uint group;
};

const uint[10] joo = {1,
                      10,
                      100,
                      1000,
                      10000,
                      100000,
                      1000000,
                      10000000,
                      100000000,
                      1000000000};

struct CharInformation {
    uint counter;
    vec3 position;
    uint[MAX_NUM_CHARS] chars;
};

// 2 x float
shared uint[2] counter;

// 136 x float
// The auxiliar scan block array
shared uint shared_aux[SCAN_BLOCK_SIZE];

// 136 x float
// The output of global active fmm block scan.
shared uint[SCAN_BLOCK_SIZE] shared_prefix_sum;

//// The counter for active fmm blocks.
shared uint stream_compaction_count;

// Debugging.
//shared CharInformation[THREAD_COUNT] char_arrays;
shared CharInformation[THREAD_COUNT] char_arrays;

const uvec3 local_dimension = uvec3(4,4,4);
const uvec3 group_dimension = uvec3(4,4,4);

const uint bez_indices[17] = {
    104| (108 << 8) | (112 << 16) | (116 << 24),  // 0       
    4  | (8 << 8) | (12 << 16) | (255 << 24),     // 1       
    16 | (20 << 8) | (24 << 16) | (255 << 24),    // 2       
    28 | (32 << 8) | (255 << 16) | (255 << 24),   // 3       
    36 | (40 << 8) | (44 << 16) | (255 << 24),    // 4       
    48 | (52 << 8) | (56 << 16) | (255 << 24),    // 5       
    60 | (64 << 8) | (68 << 16) | (255 << 24),    // 6       
    48 | (72 << 8) | (255 << 16) | (255 << 24),   // 7       
    76 | (80 << 8) | (84 << 16) | (88 << 24),     // 8       
    92 | (96 << 8) | (100 << 16) | (255 << 24),   // 9       
    0  | (255 << 8) | (255 << 16) | (255 << 24),  // 10
    104 | (112 << 8) | (255 << 16) | (255 << 24), // 11
    108 | (116 << 8) | (255 << 16) | (255 << 24), // 12
    148 | (152 << 8) | (156 << 16) | (160 << 24), // 13
    120 | (124 << 8) | (128 << 16) | (132 << 24), // 14
    136 | (140 << 8) | (144 << 16) | (255 << 24), // 15
    255 | (255 << 8) | (255 << 16) | (255 << 24), // 16
};

const vec4 bez_table[164] = {
    // Bez minus. 
    vec4(0.3, 0.5, 0.0, 0.25),     // 0
    vec4(0.433333, 0.5, 0.0, 0.0), // 1
    vec4(0.566666, 0.5, 0.0, 0.0), // 2
    vec4(0.7, 0.5, 0.0, 0.0),      // 3 

    // Bez 1.
    vec4(0.3, 0.1, 0.0, 4.0/14.0), // 4
    vec4(0.433333, 0.1, 0.0, 0.0), // 5
    vec4(0.566666, 0.1, 0.0, 0.0), // 6
    vec4(0.7, 0.1, 0.0, 0.0),      // 7 
    vec4(0.5, 0.1, 0.0, 8.0/14.0), // 8
    vec4(0.5, 0.366666, 0.0, 0.0), // 9
    vec4(0.5, 0.633333, 0.0, 0.0), // 10 
    vec4(0.5, 0.9, 0.0, 0.0),      // 11 
    vec4(0.5, 0.9, 0.0, 2.0/14.0), // 12 
    vec4(0.4, 0.8, 0.0, 0.0),      // 13 
    vec4(0.35, 0.8, 0.0, 0.0),     // 14 
    vec4(0.3, 0.8, 0.0, 0.0),      // 15 

    // Bez 2.
    vec4(0.3, 0.1, 0.0, 5.0/15.0),  // 16 
    vec4(0.433333, 0.1, 0.0, 0.0),  // 17 
    vec4(0.566666, 0.1, 0.0, 0.0),  // 18 
    vec4(0.7, 0.1, 0.0, 0.0),       // 19 
    vec4(0.3, 0.1, 0.0, 5.5/15.0),  // 20 
    vec4(0.416666, 0.3, 0.0, 0.0),  // 21 
    vec4(0.533333, 0.4, 0.0, 0.0),  // 22
    vec4(0.65, 0.55, 0.0, 0.0),     // 23 
    vec4(0.65, 0.55, 0.0, 6.5/15.0),// 24 
    vec4(0.8, 0.7, 0.0, 0.0),       // 25
    vec4(0.55, 1.08, 0.0, 0.0),     // 26
    vec4(0.3, 0.8, 0.0, 0.0),       // 27

    // Number 3
    vec4(0.3, 0.8, 0.0, 0.5),      // 28
    vec4(0.5, 1.1, 0.0, 0.0),      // 29
    vec4(0.95, 0.7, 0.0, 0.0),     // 30
    vec4(0.45, 0.55, 0.0, 0.0),    // 31
    vec4(0.45, 0.55, 0.0, 0.5),    // 32
    vec4(1.0, 0.45, 0.0, 0.0),     // 33
    vec4(0.5, -0.15, 0.0, 0.0),    // 34
    vec4(0.3, 0.2, 0.0, 0.0),      // 35

    // Number 4
    vec4(0.6, 0.1, 0.0, 8.0/17.0),   // 36
    vec4(0.6, 0.3666666, 0.0, 0.0),  // 37
    vec4(0.6, 0.6333333, 0.0, 0.0),  // 38
    vec4(0.6, 0.9, 0.0, 0.0),        // 39
    vec4(0.6, 0.9, 0.0, 5.0/17.0),   // 40
    vec4(0.466666, 0.75, 0.0, 0.0),  // 41
    vec4(0.333333, 0.6, 0.0, 0.0),   // 42
    vec4(0.2, 0.45, 0.0, 0.0),       // 43
    
    vec4(0.2, 0.45, 0.0, 4.0/17.0),  // 44
    vec4(0.3666666, 0.45, 0.0, 0.0), // 45
    vec4(0.5333333, 0.45, 0.0, 0.0), // 46
    vec4(0.7, 0.45, 0.0, 0.0),       // 47
    
    // Number 5.
    vec4(0.3, 0.9, 0.0, 2.0/13.0),  // 48
    vec4(0.433333, 0.9, 0.0, 0.0),  // 49
    vec4(0.566666, 0.9, 0.0, 0.0),  // 50
    vec4(0.7, 0.9, 0.0, 0.0),       // 51
    vec4(0.3, 0.5, 0.0, 2.0/13.0),  // 52
    vec4(0.3, 0.633333, 0.0, 0.0),  // 53
    vec4(0.3, 0.766666, 0.0, 0.0),  // 54
    vec4(0.3, 0.9, 0.0, 0.0),       // 55
    vec4(0.3, 0.5, 0.0, 9.0/13.0),  // 56
    vec4(1.0, 0.75, 0.0, 0.0),      // 57
    vec4(0.7, -0.2, 0.0, 0.0),      // 58
    vec4(0.3, 0.2, 0.0, 0.0),       // 59

    // Number 6
    vec4(0.7, 0.8, 0.0, 5.0/21.0),  // 60
    vec4(0.5, 1.05, 0.0, 0.0),      // 61
    vec4(0.3, 0.8, 0.0, 0.0),       // 62
    vec4(0.3, 0.5, 0.0, 0.0),       // 63
    vec4(0.3, 0.5, 0.0, 9.0/21.0),  // 64
    vec4(0.3, -0.05, 0.0, 0.0),     // 65
    vec4(0.7, 0.0, 0.0, 0.0),       // 66
    vec4(0.72, 0.4, 0.0, 0.0),      // 67
    vec4(0.72, 0.4, 0.0, 5.0/21.0), // 68
    vec4(0.72, 0.6, 0.0, 0.0),      // 69
    vec4(0.5, 0.7, 0.0, 0.0),       // 70
    vec4(0.3, 0.5, 0.0, 0.0),       // 71
    
    // Number 7 .
    // five_bez_a
    vec4(0.4, 0.1, 0.0, 6.0/13.0), // 72
    vec4(0.5, 0.366666, 0.0, 0.0), // 73
    vec4(0.6, 0.633333, 0.0, 0.0), // 74
    vec4(0.7, 0.9, 0.0, 0.0),      // 75
    
    
    // Number 8
    vec4(0.5, 0.9, 0.0, 0.25), // 76
    vec4(0.2, 0.85, 0.0, 0.0), // 77
    vec4(0.2, 0.55, 0.0, 0.0), // 78
    vec4(0.5, 0.5, 0.0, 0.0),  // 79
    vec4(0.5, 0.9, 0.0, 0.25), // 80
    vec4(0.8, 0.85, 0.0, 0.0), // 81
    vec4(0.8, 0.55, 0.0, 0.0), // 82
    vec4(0.5, 0.5, 0.0, 0.0),  // 83
    vec4(0.5, 0.1, 0.0, 0.25), // 84
    vec4(0.8, 0.15, 0.0, 0.0), // 85
    vec4(0.8, 0.45, 0.0, 0.0), // 86
    vec4(0.5, 0.5, 0.0, 0.0),  // 87
    vec4(0.5, 0.1, 0.0, 0.25), // 88
    vec4(0.2, 0.15, 0.0, 0.0), // 89
    vec4(0.2, 0.45, 0.0, 0.0), // 90
    vec4(0.5, 0.5, 0.0, 0.0),  // 91
    
    // Number 9
    vec4(0.3, 0.2, 0.0, 8.0/20.0), // 92
    vec4(0.5, -0.05, 0.0, 0.0),    // 93
    vec4(0.7, 0.2, 0.0, 0.0),      // 94
    vec4(0.7, 0.6, 0.0, 0.0),      // 95
    vec4(0.7, 0.6, 0.0, 6.0/20.0), // 96
    vec4(0.7, 0.95, 0.0, 0.0),     // 97
    vec4(0.4, 1.0, 0.0, 0.0),      // 98
    vec4(0.28, 0.8, 0.0, 0.0),     // 99
    vec4(0.28, 0.8, 0.0, 6.0/20.0),// 100
    vec4(0.1, 0.4, 0.0, 0.0),      // 101
    vec4(0.6, 0.4, 0.0, 0.0),      // 102
    vec4(0.7, 0.6, 0.0, 0.0),      // 103
    
    // Number 0 
    vec4(0.5, 0.9, 0.0, 0.25),   // 104
    vec4(0.25, 0.85, 0.0, 0.0),  // 105
    vec4(0.25, 0.55, 0.0, 0.0),  // 106
    vec4(0.25, 0.5, 0.0, 0.0),   // 107
    vec4(0.5, 0.9, 0.0, 0.25),   // 108
    vec4(0.75, 0.85, 0.0, 0.0),  // 109
    vec4(0.75, 0.55, 0.0, 0.0),  // 110
    vec4(0.75, 0.5, 0.0, 0.0),   // 111
    vec4(0.5, 0.1, 0.0, 0.25),   // 112
    vec4(0.25, 0.15, 0.0, 0.0),  // 113
    vec4(0.25, 0.45, 0.0, 0.0),  // 114
    vec4(0.25, 0.5, 0.0, 0.0),   // 115
    vec4(0.5, 0.1, 0.0, 0.25),   // 116
    vec4(0.75, 0.15, 0.0, 0.0),  // 117
    vec4(0.75, 0.45, 0.0, 0.0),  // 118
    vec4(0.75, 0.5, 0.0, 0.0),   // 119
    
    // Number inf 
    vec4(0.5, 0.5, 0.0, 0.25),   // 120
    vec4(0.4, 0.7, 0.0, 0.0),    // 121
    vec4(0.2, 0.7, 0.0, 0.0),    // 122
    vec4(0.1, 0.5, 0.0, 0.0),    // 123  
    vec4(0.1, 0.5, 0.0, 0.25),   // 124
    vec4(0.2, 0.3, 0.0, 0.0),    // 125
    vec4(0.4, 0.3, 0.0, 0.0),    // 126
    vec4(0.5, 0.5, 0.0, 0.0),    // 127  
    vec4(0.5, 0.5, 0.0, 0.25),   // 128
    vec4(0.6, 0.7, 0.0, 0.0),    // 129
    vec4(0.8, 0.7, 0.0, 0.0),    // 130
    vec4(0.9, 0.5, 0.0, 0.0),    // 131  
    vec4(0.9, 0.5, 0.0, 0.25),   // 132
    vec4(0.8, 0.3, 0.0, 0.0),    // 133
    vec4(0.6, 0.3, 0.0, 0.0),    // 134
    vec4(0.5, 0.5, 0.0, 0.0),    // 135  
    
    // Nan
    vec4(0.2, 0.1, 0.0, 8.0/26.0), // 136
    vec4(0.2, 0.366666, 0.0, 0.0), // 137
    vec4(0.2, 0.633333, 0.0, 0.0), // 138
    vec4(0.2, 0.9, 0.0, 0.0),      // 139
    
    vec4(0.2, 0.9, 0.0, 10.0/26.0),// 140
    vec4(0.4, 0.633333, 0.0, 0.0), // 141
    vec4(0.6, 0.366666, 0.0, 0.0), // 142
    vec4(0.8, 0.1, 0.0, 0.0),      // 143
    
    vec4(0.8, 0.1, 0.0, 8.0/26.0), // 144
    vec4(0.8, 0.366666, 0.0, 0.0), // 145
    vec4(0.8, 0.633333, 0.0, 0.0), // 146
    vec4(0.8, 0.9, 0.0, 0.0),      // 147

    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.5, 0.9, 0.0, 0.15)),   // 148
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.25, 0.85, 0.0, 0.0)),  // 149
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.25, 0.55, 0.0, 0.0)),  // 150
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.25, 0.5, 0.0, 0.0)),   // 151
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.5, 0.9, 0.0, 0.15)),   // 152
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.75, 0.85, 0.0, 0.0)),  // 153
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.75, 0.55, 0.0, 0.0)),  // 154
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.75, 0.5, 0.0, 0.0)),   // 155
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.5, 0.1, 0.0, 0.15)),   // 156
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.25, 0.15, 0.0, 0.0)),  // 157
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.25, 0.45, 0.0, 0.0)),  // 158
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.25, 0.5, 0.0, 0.0)),   // 159
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.5, 0.1, 0.0, 0.15)),   // 160
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.75, 0.15, 0.0, 0.0)),  // 161
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.75, 0.45, 0.0, 0.0)),  // 162
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.75, 0.5, 0.0, 0.0))    // 163
};

// Encode vector to "rgba" uint.
uint encode_rgba_u32(uint r, uint g, uint b, uint a) {
  uint col = 0;
  col = (r << 24) | (g << 16) | (b  << 8) | a;
  return col;
}

// TODO: rename to blocks_length or something.
uint global_data_length() {

    return fmm_attributes.global_dimensions.x *
           fmm_attributes.global_dimensions.y *
           fmm_attributes.global_dimensions.z;
}


// Updates counter until MAX_NUM_CHARS is reached.
// Returns the counter value before incrementation. 
uint update_counter() {
    uint local_index = local_id_to_x();
    uint counter_now = char_arrays[local_index].counter;
    char_arrays[local_index].counter = min(counter_now + 1, MAX_NUM_CHARS-1);
    return counter_now;
}

void create_point_ball(vec3 pos, uint r, uint g, uint b, float dist) {
    
    uint index = atomicAdd(counter[0], 1);
    output_points[index] = OutputVertex(pos, encode_rgba_u32(r, g, b, 1)); 
}

void create_point_ball7(vec3 pos, uint r, uint g, uint b, float dist) {
    
    uint index = atomicAdd(counter[0], 7);
    output_points[index] = OutputVertex(pos, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+1] = OutputVertex(pos + vec3(dist , 0.0, 0.0), encode_rgba_u32(r, g, b, 1)); 
    output_points[index+2] = OutputVertex(pos + vec3(-dist , 0.0, 0.0), encode_rgba_u32(r, g, b, 1)); 
    output_points[index+3] = OutputVertex(pos + vec3(0.0 , dist , 0.0), encode_rgba_u32(r, g, b, 1)); 
    output_points[index+4] = OutputVertex(pos + vec3(0.0 , -dist, 0.0), encode_rgba_u32(r, g, b, 1)); 
    output_points[index+5] = OutputVertex(pos + vec3(0.0 , dist , dist ), encode_rgba_u32(r, g, b, 1)); 
    output_points[index+6] = OutputVertex(pos + vec3(0.0 , -dist, -dist), encode_rgba_u32(r, g, b, 1)); 
}

void create_aabb_triangles(AABB aabb, uint r, uint g, uint b) {

    uint aabb_index = atomicAdd(counter[1], 24);

    const vec3 delta = aabb.max.xyz - aabb.min.xyz;
    const vec3 p0 = aabb.min.xyz;
    const vec3 p1 = aabb.min.xyz + vec3(delta.x , 0.0     , 0.0);
    const vec3 p2 = aabb.min.xyz + vec3(delta.x , delta.y , 0.0);
    const vec3 p3 = aabb.min.xyz + vec3(0.0     , delta.y , 0.0);
    const vec3 p4 = aabb.min.xyz + vec3(0.0     , 0.0     , delta.z);
    const vec3 p5 = aabb.min.xyz + vec3(delta.x , 0.0     , delta.z);
    const vec3 p6 = aabb.min.xyz + vec3(delta.x , delta.y , delta.z);
    const vec3 p7 = aabb.min.xyz + vec3(0.0     , delta.y , delta.z);

    OutputVertex p0_out = OutputVertex( p0, encode_rgba_u32(r, g, b, 0));
    OutputVertex p1_out = OutputVertex( p1, encode_rgba_u32(r, g, b, 0));
    OutputVertex p2_out = OutputVertex( p2, encode_rgba_u32(r, g, b, 0));
    OutputVertex p3_out = OutputVertex( p3, encode_rgba_u32(r, g, b, 0));
    OutputVertex p4_out = OutputVertex( p4, encode_rgba_u32(r, g, b, 0));
    OutputVertex p5_out = OutputVertex( p5, encode_rgba_u32(r, g, b, 0));
    OutputVertex p6_out = OutputVertex( p6, encode_rgba_u32(r, g, b, 0));
    OutputVertex p7_out = OutputVertex( p7, encode_rgba_u32(r, g, b, 0));
}


// TODO rename to triangles.
void create_output_points(AABB aabb, uint r, uint g, uint b) {

    uint aabb_index = atomicAdd(counter[1], 36);

    const vec3 delta = aabb.max.xyz - aabb.min.xyz;
    const vec3 p0 = aabb.min.xyz;
    const vec3 p1 = aabb.min.xyz + vec3(delta.x , 0.0     , 0.0);
    const vec3 p2 = aabb.min.xyz + vec3(delta.x , delta.y , 0.0);
    const vec3 p3 = aabb.min.xyz + vec3(0.0     , delta.y , 0.0);
    const vec3 p4 = aabb.min.xyz + vec3(0.0     , 0.0     , delta.z);
    const vec3 p5 = aabb.min.xyz + vec3(delta.x , 0.0     , delta.z);
    const vec3 p6 = aabb.min.xyz + vec3(delta.x , delta.y , delta.z);
    const vec3 p7 = aabb.min.xyz + vec3(0.0     , delta.y , delta.z);

    // FRONT.

    const float lf_factor = 0.3;
    const uint lfr = uint(r*lf_factor);
    const uint lfg = uint(g*lf_factor);
    const uint lfb = uint(b*lf_factor);

    output_points[aabb_index]   = OutputVertex(p6, encode_rgba_u32(lfr, lfg, lfb, 1)); 
    output_points[aabb_index+1] = OutputVertex(p7, encode_rgba_u32(lfr, lfg, lfb, 1)); 
    output_points[aabb_index+2] = OutputVertex(p4, encode_rgba_u32(lfr, lfg, lfb, 1)); 

    output_points[aabb_index+3] = OutputVertex(p4, encode_rgba_u32(lfr, lfg, lfb, 1)); 
    output_points[aabb_index+4] = OutputVertex(p5, encode_rgba_u32(lfr, lfg, lfb, 1)); 
    output_points[aabb_index+5] = OutputVertex(p6, encode_rgba_u32(lfr, lfg, lfb, 1)); 

    // RIGHT.

    const float lr_factor = 0.6;
    const uint lrr = uint(r*lr_factor);
    const uint lrg = uint(g*lr_factor);
    const uint lrb = uint(b*lr_factor);

    output_points[aabb_index+6] = OutputVertex(p5, encode_rgba_u32(lrr, lrg, lrb, 1)); 
    output_points[aabb_index+7] = OutputVertex(p1, encode_rgba_u32(lrr, lrg, lrb, 1)); 
    output_points[aabb_index+8] = OutputVertex(p2, encode_rgba_u32(lrr, lrg, lrb, 1)); 

    output_points[aabb_index+9]  = OutputVertex(p2, encode_rgba_u32(lrr, lrg, lrb, 1)); 
    output_points[aabb_index+10] = OutputVertex(p6, encode_rgba_u32(lrr, lrg, lrb, 1)); 
    output_points[aabb_index+11] = OutputVertex(p5, encode_rgba_u32(lrr, lrg, lrb, 1)); 

    // BACK.

    output_points[aabb_index+12] = OutputVertex(p2, encode_rgba_u32(r, g, b, 1)); 
    output_points[aabb_index+13] = OutputVertex(p1, encode_rgba_u32(r, g, b, 1)); 
    output_points[aabb_index+14] = OutputVertex(p0, encode_rgba_u32(r, g, b, 1)); 

    output_points[aabb_index+15] = OutputVertex(p3, encode_rgba_u32(r, g, b, 1)); 
    output_points[aabb_index+16] = OutputVertex(p2, encode_rgba_u32(r, g, b, 1)); 
    output_points[aabb_index+17] = OutputVertex(p0, encode_rgba_u32(r, g, b, 1)); 

    // LEFT.

    const float ll_factor = 0.6;
    const uint llr = uint(r*ll_factor);
    const uint llg = uint(g*ll_factor);
    const uint llb = uint(b*ll_factor);

    output_points[aabb_index+18] = OutputVertex(p7, encode_rgba_u32(llr, llg, llb, 1)); 
    output_points[aabb_index+19] = OutputVertex(p3, encode_rgba_u32(llr, llg, llb, 1)); 
    output_points[aabb_index+20] = OutputVertex(p0, encode_rgba_u32(llr, llg, llb, 1)); 

    output_points[aabb_index+21] = OutputVertex(p0, encode_rgba_u32(llr, llg, llb, 1)); 
    output_points[aabb_index+22] = OutputVertex(p4, encode_rgba_u32(llr, llg, llb, 1)); 
    output_points[aabb_index+23] = OutputVertex(p7, encode_rgba_u32(llr, llg, llb, 1)); 

    // TOP.

    const float lt_factor = 0.8;
    const uint ltr = uint(r*lt_factor);
    const uint ltg = uint(g*lt_factor);
    const uint ltb = uint(b*lt_factor);

    output_points[aabb_index+24] = OutputVertex(p7, encode_rgba_u32(ltr, ltg, ltb, 1)); 
    output_points[aabb_index+25] = OutputVertex(p6, encode_rgba_u32(ltr, ltg, ltb, 1)); 
    output_points[aabb_index+26] = OutputVertex(p2, encode_rgba_u32(ltr, ltg, ltb, 1)); 

    output_points[aabb_index+27] = OutputVertex(p2, encode_rgba_u32(ltr, ltg, ltb, 1)); 
    output_points[aabb_index+28] = OutputVertex(p3, encode_rgba_u32(ltr, ltg, ltb, 1)); 
    output_points[aabb_index+29] = OutputVertex(p7, encode_rgba_u32(ltr, ltg, ltb, 1)); 

    // BOTTOM.

    const float lb_factor = 0.15;
    const uint lbr = uint(r*lb_factor);
    const uint lbg = uint(g*lb_factor);
    const uint lbb = uint(b*lb_factor);

    output_points[aabb_index+30] = OutputVertex(p1, encode_rgba_u32(lbr, lbg, lbb, 1)); 
    output_points[aabb_index+31] = OutputVertex(p5, encode_rgba_u32(lbr, lbg, lbb, 1)); 
    output_points[aabb_index+32] = OutputVertex(p4, encode_rgba_u32(lbr, lbg, lbb, 1)); 

    output_points[aabb_index+33] = OutputVertex(p4, encode_rgba_u32(lbr, lbg, lbb, 1)); 
    output_points[aabb_index+34] = OutputVertex(p0, encode_rgba_u32(lbr, lbg, lbb, 1)); 
    output_points[aabb_index+35] = OutputVertex(p1, encode_rgba_u32(lbr, lbg, lbb, 1)); 
}

void create_aabb_triangles_r(AABB aabb, uint r, uint g, uint b, float t) {
    AABB back_bottom = AABB(aabb.min, vec4(aabb.max.x, aabb.min.y + t, aabb.min.z + t, 1.0));
    AABB right_bottom = AABB(aabb.min, vec4(aabb.min.x + t, aabb.min.y + t, aabb.max.z, 1.0));
    AABB left_bottom = AABB(vec4(aabb.max.x - t, aabb.min.y, aabb.min.z, 1.0),
                            vec4(aabb.max.x, aabb.min.y + t, aabb.max.z, 1.0));
    AABB front_bottom = AABB(vec4(aabb.min.x, aabb.min.y, aabb.max.z - t, 1.0),
                             vec4(aabb.max.x, aabb.min.y + t, aabb.max.z, 1.0));

    AABB back_top = AABB(vec4(aabb.min.x, aabb.max.y - t, aabb.min.z, 1.0),  
                         vec4(aabb.max.x, aabb.max.y,     aabb.min.z + t, 1.0));
    AABB left_top = AABB(vec4(aabb.min.x,     aabb.max.y - t, aabb.min.z, 1.0),  
                          vec4(aabb.min.x + t, aabb.max.y,     aabb.max.z, 1.0));
    AABB right_top = AABB(vec4(aabb.max.x - t, aabb.max.y - t, aabb.min.z, 1.0),  
                          vec4(aabb.max.x,     aabb.max.y,     aabb.max.z, 1.0));
    AABB front_top = AABB(vec4(aabb.min.x,     aabb.max.y - t, aabb.max.z - t, 1.0),  
                          vec4(aabb.max.x,     aabb.max.y,     aabb.max.z, 1.0));
    AABB back_left_ud = AABB(vec4(aabb.min.x,     aabb.min.y, aabb.min.z, 1.0),  
                             vec4(aabb.min.x + t, aabb.max.y, aabb.min.z + t, 1.0));
    AABB back_right_ud = AABB(vec4(aabb.max.x - t, aabb.min.y, aabb.min.z, 1.0),  
                              vec4(aabb.max.x    , aabb.max.y, aabb.min.z + t, 1.0));
    AABB front_right_ud = AABB(vec4(aabb.min.x,    aabb.min.y, aabb.max.z - t, 1.0),  
                              vec4(aabb.min.x + t, aabb.max.y, aabb.max.z, 1.0));
    AABB front_left_ud = AABB(vec4(aabb.max.x - t, aabb.min.y, aabb.max.z - t, 1.0),  
                              vec4(aabb.max.x    , aabb.max.y, aabb.max.z, 1.0));
    create_output_points(back_bottom, r, g, b); 
    create_output_points(right_bottom, r, g, b); 
    create_output_points(left_bottom, r, g, b); 
    create_output_points(front_bottom, r, g, b); 
    create_output_points(back_top, r, g, b); 
    create_output_points(left_top, r, g, b); 
    create_output_points(right_top, r, g, b); 
    create_output_points(front_top, r, g, b); 
    create_output_points(back_left_ud, r, g, b); 
    create_output_points(back_right_ud, r, g, b); 
    create_output_points(front_right_ud, r, g, b); 
    create_output_points(front_left_ud, r, g, b); 
}


void bezier_4c(uint n, vec4 c0, vec4 c1, vec4 c2, vec4 c3, uint r, uint g, uint b) {

    if (n < 4) return;

    uint index = atomicAdd(counter[0], n);

    for (int i=0 ; i<n ; i++) {
        const float t = float(i)  / (float(n)-1.0);
        const float t2 = t * t;
        const float t3 = t2 * t;
        const float mt = 1.0 - t;
        const float mt2 = mt * mt;
        const float mt3 = mt2 * mt;
        const vec3 result = c0.xyz * mt3 + c1.xyz * 3.0 * mt2*t + c2.xyz * 3.0 * mt*t2 + c3.xyz * t3;
        const float dist = min(max(1.0, distance(camera_pos.xyz, result)), 255);
        output_points[index] = OutputVertex(
            result,
            encode_rgba_u32(
                r,
                g,
                b,
                uint(dist)));
        index++;
    }
}

void create_array(float array_width, vec3 base_pos, vec3 dest_pos, uint r, uint g, uint b) {

    vec3 array_direction = normalize(dest_pos - base_pos);
    vec3 camera_direction = normalize(camera_pos.xyz - base_pos);

    // Array length.
    float array_length = distance(dest_pos, base_pos);
    float array_base_length = array_length - array_width;

    vec3 side_direction = cross(camera_direction, array_direction);   

    uint index = atomicAdd(counter[1], 21);

    const vec3 p0 = base_pos;
    const vec3 p1 = base_pos + side_direction * array_width;
    const vec3 p2 = base_pos - side_direction * array_width;
    const vec3 p3 = p1 + array_direction * array_base_length;
    const vec3 p4 = p2 + array_direction * array_base_length;
    const vec3 p5 = base_pos + array_direction * array_base_length;
    const vec3 p6 = dest_pos;
    const vec3 p7 = p3 + side_direction * array_width * 2.0;
    const vec3 p8 = p4 - side_direction * array_width * 2.0;

    output_points[index]   = OutputVertex(p1, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+1] = OutputVertex(p0, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+2] = OutputVertex(p3, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+3] = OutputVertex(p0, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+4] = OutputVertex(p5, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+5] = OutputVertex(p3, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+6] = OutputVertex(p0, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+7] = OutputVertex(p2, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+8] = OutputVertex(p4, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+9] = OutputVertex(p4, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+10] = OutputVertex(p5, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+11] = OutputVertex(p0, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+12] = OutputVertex(p3, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+13] = OutputVertex(p4, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+14] = OutputVertex(p6, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+15] = OutputVertex(p3, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+16] = OutputVertex(p6, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+17] = OutputVertex(p7, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+18] = OutputVertex(p4, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+19] = OutputVertex(p8, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+20] = OutputVertex(p6, encode_rgba_u32(r, g, b, 1)); 
}

// uint get_remainder(uint num, uint divisor) {
//     return (num - divisor * (num / divisor));
// }

void log_number(uint n, bool ignore_first) {
       // 4294967295 
       // 1000000000
    uint local_index = local_id_to_x();

    bool found = false;
    bool ignore = ignore_first;
    uint temp_n = n;

    if (n == 0) {
        char_arrays[local_index].chars[update_counter()] = 0;
        return;
    }

    for (int i=9 ; i>=0 ; i--) {
        uint remainder = temp_n / joo[i];  
        temp_n -= remainder * joo[i];
        if (remainder != 0) {
            found = true;	    
        }
        if (found == true) {
            if (ignore == true) { ignore = false; continue; }
            char_arrays[local_index].chars[update_counter()] = remainder; 
        }
    }
}

void create_char(uint char_index, uint num_points, vec4 offset, uint r, uint g, uint b) {

    uint index = bez_indices[char_index];

    uint indices[4] = {
        index & 0xff,
        (index & 0xff00) >> 8,
        (index & 0xff0000) >> 16,
        (index & 0xff000000) >> 24,
    };

    for (uint i=0 ; i<4 ; i++) {
        uint bez_index = indices[i];
        if (bez_index == 255) break;
        vec4 bi = bez_table[bez_index];
        uint count = uint(max(1.0, num_points * bi.w));
        bezier_4c(
            count,
            FONT_SIZE * bez_table[bez_index + 0] + offset,
            FONT_SIZE * bez_table[bez_index + 1] + offset,
            FONT_SIZE * bez_table[bez_index + 2] + offset,
            FONT_SIZE * bez_table[bez_index + 3] + offset,
            r,
            g,
            b
        );
    }
}

void log_float(double f, uint max_decimals) {

    uint local_index = local_id_to_x();
    //uint counter_now = counter;

    // The sign of given float.
    bool is_negative = f < 0.0;

    // Add minus.
    if (is_negative) {
        char_arrays[local_index].chars[update_counter()] = 10;
        //char_arrays[local_index].counter++;
    }

    double f_positive = abs(f);

    // The integer part.
    float integer_temp; 

    // The fractional component.
    double _f_part = modf(float(f_positive), integer_temp);

    double f_part = fract(f_positive);

    // Multiply fractional part so it becomes uint.
    uint fract_part = uint((f_part+1.0)*joo[max_decimals]); //pow(10.0, max_decimals));

    // Cast integer part to uint.
    uint integer_part = uint(abs(integer_temp));

    // Parse the integer part.
    log_number(integer_part, false);

    // Add dot.
    char_arrays[local_index].chars[update_counter()] = 13;

    // Parse the frag part.
    log_number(fract_part, true);
}

void log_uvec3(uvec3 v) {

    uint local_index = local_id_to_x();

    // Add left paren.
    char_arrays[local_index].chars[update_counter()] = 11;

    log_number(v.x, false);

    // Add space x 2.
    char_arrays[local_index].chars[update_counter()] = 16;
    char_arrays[local_index].chars[update_counter()] = 16;

    log_number(v.y, false);

    // Add space x 2.
    char_arrays[local_index].chars[update_counter()] = 16;
    char_arrays[local_index].chars[update_counter()] = 16;

    log_number(v.z, false);
    
    // Add right paren.
    char_arrays[local_index].chars[update_counter()] = 12;

}

void log_vec3(vec3 v, uint max_decimals) {
    
    uint local_index = local_id_to_x();

    // Add left paren.
    char_arrays[local_index].chars[update_counter()] = 11;

    // log_float(double(v.x), 7);
    log_float(double(v.x), max_decimals);

    // Add space x 2.
    char_arrays[local_index].chars[update_counter()] = 16;
    char_arrays[local_index].chars[update_counter()] = 16;

    //log_float(double(v.y), 7);
    log_float(double(v.y), max_decimals);

    // Add space x 2.
    char_arrays[local_index].chars[update_counter()] = 16;
    char_arrays[local_index].chars[update_counter()] = 16;

    //log_float(double(v.z), 7);
    log_float(double(v.z), max_decimals);
    
    // Add right paren.
    char_arrays[local_index].chars[update_counter()] = 12;
}

AABB create_char_sequency_points(uint r, uint g, uint b) {

    uint local_index = local_id_to_x();
    vec3 base_vector = char_arrays[local_index].position;
    const float dist = distance(base_vector, camera_pos.xyz);
    uint average_points_per_char = max(4, uint(min(MAX_NUM_OF_POINTS, MAX_NUM_OF_POINTS / pow(dist, 2.0)))); 
    vec4 local_offset = vec4(base_vector, 0.0);
    uint number_of_lines = 0;
    uint max_text_width = 0;
    uint text_width = 0;
      
    for (uint i=0; i<char_arrays[local_index].counter; i++) {
        uint numb = char_arrays[local_index].chars[i];

        // end of line.
        if (numb == 17) {
            number_of_lines++;
            local_offset = vec4(base_vector, 0.0) + vec4(0.0, (-FONT_OFFSET_Y) * float(number_of_lines) * FONT_SIZE, 0.0, 0.0);
            if (text_width > max_text_width) {
                max_text_width = text_width;
                text_width = 0;
            }
        }
        else {
            create_char(numb, average_points_per_char, local_offset, r, g, b);
            local_offset = local_offset + vec4(FONT_SIZE * 0.7, 0.0, 0.0, 0.0);
            text_width++;
        }
    }

    AABB aabb = AABB(
      vec4(base_vector, 0.0) + vec4(-0.5 * FONT_SIZE, number_of_lines * (-FONT_OFFSET_Y - 0.1) * FONT_SIZE, -0.05, 0.0),
      vec4(base_vector, 0.0) + FONT_SIZE * vec4(max_text_width * 0.8, FONT_OFFSET_Y, 0.0, 0.0) + vec4(0.0,0.0,-0.001,0.0)
    );
    return aabb;
}

void add_end_of_line() {
    uint local_index = local_id_to_x();
    char_arrays[local_index].chars[char_arrays[local_index].counter] = 17;
    char_arrays[local_index].counter++;
}

void initialize_char_array(vec3 position) {

    uint local_index = local_id_to_x();

    char_arrays[local_index].counter = 0;
    char_arrays[local_index].position = position;
}

// Calculate uvec3 from given index and dimensions.
uvec3 index_to_uvec3(uint the_index, uint dim_x, uint dim_y) {
  uint index = the_index;
  uint wh = dim_x * dim_y;
  uint z = index / wh;
  index -= z * wh;
  uint y = index / dim_x;
  index -= y * dim_x;
  uint x = index;
  return uvec3(x, y, z);
}

void push_chars(uint r, uint g, uint b) {

  uint local_index = local_id_to_x();
  vec3 original_coord = char_arrays[local_index].position;

  AABB aabb = create_char_sequency_points(255, 125, 125);
  AABB traslated = AABB(vec4(original_coord, 1.0), vec4(original_coord + vec3(1.0, 1.0, 1.0), 1.0));
  create_output_points(aabb,
                    r,
                    g,
                    b
                    );
}

void reset_thread_checker() {
    thread_check_table[gl_LocalInvocationIndex] = 0;
}

void check_threads() {
    thread_check_table[gl_LocalInvocationIndex] = 1;
}

void print_threads() {
    if (gl_LocalInvocationIndex == 0) {

        for (int i=0 ; i<THREAD_COUNT ; i++) {
            uvec3 final_color = thread_check_table[i] == 0 ? uvec3(255,0,0) : uvec3(0,255,0);

            vec3 this_pah = vec3(mod(i,LOCAL_X_DIM), 5 - i/LOCAL_X_DIM, 0) * 0.5;
            initialize_char_array(this_pah);
            log_number(i, false);
            add_end_of_line();
            AABB aabb = create_char_sequency_points(0,0,0);
            AABB traslated = AABB(vec4(this_pah, 1.0), vec4(this_pah + vec3(1.0, 1.0, 1.0), 1.0));
            create_output_points(aabb, final_color.x, final_color.y, final_color.z);
        }
    }
    barrier();
}

void check_all_threads() {
  reset_thread_checker();
  barrier();
  check_threads();
  barrier();
  print_threads();
}

// Add a chunk of block data to a temporary shared_perix_sum buffer.
// Copies FMM_Block to shared_prefix_sum {0,1}. Add padding 0 if necessery.
void copy_block_to_temp(uint chunck_id, uint number_of_items) {

    // Create the local indices.
    const uint ai = local_id_to_x(); 
    const uint bi = ai + THREAD_COUNT;

    // Create the bank conflict free local indices.
    const uint ai_bcf = ai + (ai >> 4); 
    const uint bi_bcf = bi + (bi >> 4);

    // Create the global indices to access the global memory.
    const uint global_ai = ai + chunck_id * (THREAD_COUNT * 2);
    const uint global_bi = bi + chunck_id * (THREAD_COUNT * 2);

    // Create {0:1} array from the global fmm_block array.
    // 0 :: no band cells.
    // 1 :: band cells > 0.

    FMM_Block a = fmm_block[global_ai];
    FMM_Block b = fmm_block[global_bi];

    shared_prefix_sum[ai_bcf] = ai < number_of_items && a.band_points_count > 0 ? 1 : 0;
    shared_prefix_sum[bi_bcf] = bi < number_of_items && b.band_points_count > 0 ? 1 : 0;
    //shared_prefix_sum[ai_bcf] = uint((ai < number_of_items) && (a.band_points_count > 0));
    //shared_prefix_sum[bi_bcf] = uint((bi < number_of_items) && (b.band_points_count > 0));
}

void copy_prefix_sum_to_temp(uint chunck_id) {

    // Create the local indices.
    const uint ai = local_id_to_x(); 
    const uint bi = ai + THREAD_COUNT;

    // Create the bank conflict free local indices.
    const uint ai_bcf = ai + (ai >> 4); 
    const uint bi_bcf = bi + (bi >> 4);

    // Create the global indices to access the global memory.
    const uint global_ai = ai + chunck_id * (THREAD_COUNT * 2);
    const uint global_bi = bi + chunck_id * (THREAD_COUNT * 2);

    temp_prefix_sum[global_ai] = shared_prefix_sum[ai_bcf];
    temp_prefix_sum[global_bi] = shared_prefix_sum[bi_bcf];
}

// Perform prefix sum. Return the exclusive part of the prefix sum.
// NOTE: only the thread 0 returns the actual exclusive part.
uint local_prefix_sum() {

    // Create the local indices.
    const uint ai = local_id_to_x(); 
    const uint bi = ai + THREAD_COUNT;

    // Create the bank conflict free local indices.
    const uint ai_bcf = ai + (ai >> 4); 
    const uint bi_bcf = bi + (bi >> 4);

    uint exclusive_part = 0;

    // Up sweep.

    const int n = THREAD_COUNT*2;
    int offset = 1;
    for (int d = n>>1 ; d > 0; d >>= 1) {
      barrier();
      if (ai < d) {

          int ai_temp = offset*(int(ai*2)+1)-1; // 0, 2, 4, 6
          int bi_temp = offset*(int(ai*2)+2)-1; // 1, 3, 5, 7

          ai_temp += (ai_temp >> 4);
          bi_temp += (bi_temp >> 4);

          shared_prefix_sum[bi_temp] += shared_prefix_sum[ai_temp];
      }
      offset *= 2;
    }
    barrier();
      
    // Clear the last item. 
    if (ai == 0) {

        // Global last index.
        uint last_index = (THREAD_COUNT * 2) -1 + ((THREAD_COUNT * 2 - 1) >> 4);

        // Copy the last prefix sum to the shared_aux. 
        exclusive_part = shared_prefix_sum[last_index];

        // Add zero to the last index.
        shared_prefix_sum[last_index] = 0;
    }
    // BARRIER?
    
    // Down sweep.
    for (int d = 1; d < n ; d *=2) {
      offset >>= 1;
      barrier();
      if (ai < d) {
          int ai_temp = offset*(int(ai*2)+1)-1;
          int bi_temp = offset*(int(ai*2)+2)-1;
          ai_temp += (ai_temp >> 4);
          bi_temp += (bi_temp >> 4);
          uint t = shared_prefix_sum[ai_temp];

          shared_prefix_sum[ai_temp] = shared_prefix_sum[bi_temp];
          shared_prefix_sum[bi_temp] += t;
      }
  }
  return exclusive_part;
}

// Perform prefix sum for shared_aux. Return the exclusive part of the prefix sum.
uint local_prefix_sum_aux() {

    // Create the local indices.
    const uint ai = local_id_to_x(); 
    const uint bi = ai + THREAD_COUNT;

    // Create the bank conflict free local indices.
    const uint ai_bcf = ai + (ai >> 4); 
    const uint bi_bcf = bi + (bi >> 4);

    uint exclusive_part = 0; // TODO: not used! remove.

    // Up sweep.

    const int n = THREAD_COUNT*2;
    int offset = 1;
    for (int d = n>>1 ; d > 0; d >>= 1) {
      barrier();
      if (ai < d) {

          int ai_temp = offset*(int(ai*2)+1)-1; // 0, 2, 4, 6
          int bi_temp = offset*(int(ai*2)+2)-1; // 1, 3, 5, 7

          ai_temp += (ai_temp >> 4);
          bi_temp += (bi_temp >> 4);

          shared_aux[bi_temp] += shared_aux[ai_temp];
      }
      offset *= 2;
    }
    barrier();
      
    // Clear the last item. 
    //if (ai == 0) {
    if (gl_LocalInvocationIndex == 0) {

        // Global last index.
        uint last_index = (THREAD_COUNT * 2) -1 + ((THREAD_COUNT * 2 - 1) >> 4);

        // Copy the last prefix sum to the shared_aux. 
        stream_compaction_count = shared_aux[last_index];

        vec3 this_pah = vec3(0, -8, 0);
        initialize_char_array(this_pah);
        //log_number(index_to_add, false);
        //log_number(index_to_add_a + active_fmm_blocks_offset, false);
        //log_number(index_to_add_a, false);
        log_number(stream_compaction_count, false);
        add_end_of_line();
        AABB aabb = create_char_sequency_points(255,25,25);
        AABB traslated = AABB(vec4(this_pah, 1.0), vec4(this_pah + vec3(1.0, 1.0, 1.0), 1.0));
        create_output_points(aabb, 0,125,255);

        // Add zero to the last index.
        shared_aux[last_index] = 0;
    }
    // BARRIER?
    
    // Down sweep.
    for (int d = 1; d < n ; d *=2) {
      offset >>= 1;
      barrier();
      if (ai < d) {
          int ai_temp = offset*(int(ai*2)+1)-1;
          int bi_temp = offset*(int(ai*2)+2)-1;
          ai_temp += (ai_temp >> 4);
          bi_temp += (bi_temp >> 4);
          uint t = shared_aux[ai_temp];

          shared_aux[ai_temp] = shared_aux[bi_temp];
          shared_aux[bi_temp] += t;
      }
  }
  return exclusive_part;
}

// Stream compation.
void solve_active_fmm_block(uint number_of_scan_blocks) {

    for (int j=0 ; j < number_of_scan_blocks ; j++) {
    
      const uint ai = gl_LocalInvocationIndex + j * THREAD_COUNT * 2;
      const uint bi = (gl_LocalInvocationIndex + THREAD_COUNT) + j * THREAD_COUNT * 2;

      const uint active_fmm_blocks_offset = global_data_length();
    
      FMM_Block a = fmm_block[ai];
      FMM_Block b = fmm_block[bi];
    
      bool add_a = a.band_points_count > 0;
      bool add_b = b.band_points_count > 0;
    
      uint index_to_add_a = temp_prefix_sum[ai];
      uint index_to_add_b = temp_prefix_sum[bi];

      if (add_a && ai < active_fmm_blocks_offset) {
          fmm_block[index_to_add_a + active_fmm_blocks_offset] = a;
      }
      if (add_b && bi < active_fmm_blocks_offset) {
          fmm_block[index_to_add_b + active_fmm_blocks_offset] = b;
      }
    }
}

uint global_solver() {

  uint number_of_blocks = global_data_length();

  // Convert 4x4x4 index to uint.
  uint local_id_x = local_id_to_x();

  // Reset the counter for active blocks. 
  if (gl_LocalInvocationIndex == 0) stream_compaction_count = 0;
  barrier();
  
  // Number of data chunks. There must be at least one iteration.
  // neeeded. TODO: check number_of_blocks == 0. Return immediatelly if it
  // true.
  const uint number_of_scan_blocks = (number_of_blocks - 1) / (THREAD_COUNT*2) + 1;

  // Available items count.
  uint items_available = number_of_blocks;

  // The number of items on current chunk.
  uint number_of_taken_items = 0; 

  // Create the local indices.
  const uint ai = local_id_to_x(); 
  const uint bi = ai + THREAD_COUNT;

  // Create the local indices.
  const uint ai_bcf = ai + (ai >> 4); 
  const uint bi_bcf = bi + (bi >> 4);
  
  // Add zeroes to the shared_aux (the conflict free indexes).
  shared_aux[ai_bcf] = 0;
  shared_aux[bi_bcf] = 0;
  barrier();

  // Perfom prefix sum on boolean array.
  for (int j=0 ; j < number_of_scan_blocks ; j++) {

      // Determine the count of items in this iteration.
      number_of_taken_items = min(THREAD_COUNT * 2, items_available);

      // Decrease the number of available items.
      items_available -= number_of_taken_items;

      // Copy data from global FMM_Block array to
      // shared_prefix_sum. [{0,1}]
      copy_block_to_temp(j, number_of_taken_items);
      barrier(); // ???

      // Perform the prefix_sum.
      uint exclusive_part = local_prefix_sum();
      barrier(); // ???

      // Add the exclusive part to the shared aux.
      if (local_id_x == 0) shared_aux[j + (j >> 4)] = exclusive_part; 
      barrier();

      // Copy local prefix sum data to temp_prefix_sum buffer.
      copy_prefix_sum_to_temp(j);
      barrier(); // ???
  }

  // Perform the prefix_sum for shared_aux.
  local_prefix_sum_aux();
  barrier(); // ??

  // Add the shared_aux to the final result.
  for (int j=0 ; j < number_of_scan_blocks ; j++) {
    uint value_to_add = shared_aux[j + (j >> 4)]; 

    // Create the global indices to access the global memory.
    const uint global_ai = ai + j * (THREAD_COUNT * 2);
    const uint global_bi = bi + j * (THREAD_COUNT * 2);

    temp_prefix_sum[global_ai] += value_to_add; 
    temp_prefix_sum[global_bi] += value_to_add; 
  }
  barrier(); // ??

  // Finally. Update the number of active FMM_Blocks.
  solve_active_fmm_block(number_of_scan_blocks);
  barrier(); //??

  return stream_compaction_count;
}

// Return BlockData with block global position and the 
// index base index (in node dimension).
BlockData get_block_pos_index(uint block_index) {

    uvec3 ijk = index_to_uvec3(
                  block_index,
                  fmm_attributes.global_dimensions.x,
                  fmm_attributes.global_dimensions.y
    );

    return BlockData(ivec3(ijk),
                     ijk.x * 64 +
                     ijk.y * 64 * fmm_attributes.global_dimensions.x +
                     ijk.z * 64 * fmm_attributes.global_dimensions.x * fmm_attributes.global_dimensions.y);
}

void copy_offset_to_shared(uint thread_id) {
    shared_offset_table[thread_id] = offset_hash_table[thread_id];
}

void copy_vec_to_offset_to_shared(uint thread_id) {
    shared_vec_to_offset[thread_id] = vec_to_offset_table[thread_id];
}

// Calculate from local coordinate to local shared index (map from local indes
// to local index hash map value.
// Prerequisites: shared_vec_to_offset must be initialized before using this function.
uint get_transformed_index(ivec3 position) {
    const ivec3 transformed_position = position + ivec3(1,1,1);
    const uint position_index = transformed_position.x + transformed_position.y * 6 + transformed_position.z * 36;
    return shared_vec_to_offset[position_index];
}

// Loads offset hash table to shared memory.
void load_offset_hash_table() {

  //const uint number_of_threads = LOCAL_X_DIM * LOCAL_Y_DIM;  
  const uint number_of_offset_blocks = (fmm_attributes.offset_hash_table_size - 1) / THREAD_COUNT + 1;

  for (int j=0 ; j < number_of_offset_blocks ; j++) {
      const uint thread_id = j * THREAD_COUNT + gl_LocalInvocationIndex;
      if (thread_id >= fmm_attributes.offset_hash_table_size) break;
      copy_offset_to_shared(thread_id);
  }
}

// Loads vec to offset hash table to shared memory.
void load_vec_to_offset() {

  //const uint number_of_threads = LOCAL_X_DIM * LOCAL_Y_DIM;  
  const uint number_of_vec_to_offset_blocks = (fmm_attributes.vec_to_offset_table_size - 1) / THREAD_COUNT + 1;

  for (int j=0 ; j < number_of_vec_to_offset_blocks ; j++) {

      const uint thread_id = j * THREAD_COUNT + gl_LocalInvocationIndex;
      if (thread_id >= fmm_attributes.vec_to_offset_table_size) break;
      copy_vec_to_offset_to_shared(thread_id);
  }
}

// Load fmm node data to shared memory. Does not get data from outside
// global computational context.
void load_fmm_data(uint base_index, ivec3 global_base_coord, bool center_data_only) {

    const uint number_of_blocks =
        center_data_only ? 1 : (fmm_attributes.offset_hash_table_size - 1) / 64 + 1;

    for (int x=0 ; x < number_of_blocks ; x++) {

        const uint thread_id = x * 64 + gl_LocalInvocationID.x;

        if (thread_id < fmm_attributes.offset_hash_table_size) {

            const ivec4 pos_and_offset = shared_offset_table[thread_id];
            ivec3 global_index = pos_and_offset.xyz + global_base_coord;

            bool outside = global_index.x < 0 ||
                           global_index.y < 0 ||
                           global_index.z < 0 ||
                           global_index.x >= fmm_attributes.global_dimensions.x*4 ||
                           global_index.y >= fmm_attributes.global_dimensions.y*4 ||
                           global_index.z >= fmm_attributes.global_dimensions.z*4;

            shared_fmm_nodes[thread_id + gl_LocalInvocationID.y * 160] = 
                outside ? FMM_Node(0.0, 5) : fmm_nodes[pos_and_offset.w + int(base_index)];

        }
    }
}

void save_fmm_data(uint base_index, ivec3 global_base_index, bool center_data_only) {

    const uint number_of_blocks =
        center_data_only ? 1 : (fmm_attributes.offset_hash_table_size - 1) / 64 + 1;

    for (int x=0 ; x < number_of_blocks ; x++) {

        const uint thread_id = x * 64 + gl_LocalInvocationID.x;

        if (thread_id < fmm_attributes.offset_hash_table_size) {

            const ivec4 pos_and_offset = offset_hash_table[thread_id];
            ivec3 global_index = pos_and_offset.xyz + global_base_index;

            bool outside = global_index.x < 0 ||
                           global_index.y < 0 ||
                           global_index.z < 0 ||
                           global_index.x >= fmm_attributes.global_dimensions.x*4 ||
                           global_index.y >= fmm_attributes.global_dimensions.y*4 ||
                           global_index.z >= fmm_attributes.global_dimensions.z*4;
            if (!outside) {
                fmm_nodes[pos_and_offset.w + int(base_index)] = shared_fmm_nodes[thread_id + gl_LocalInvocationID.y * 160]; 
            }
        }
    }
}

// 
//     -x       +x       -y        +y      -z       +z   
//  +--------+--------+--------+--------+--------+--------+
//  |  0     |   1    |   2    |   3    |   4    |   5    | 
//  +--------+--------+--------+--------+--------+--------+
// 
void get_neighbors(uint cell_index, uint work_index, out FMM_Node[6] neighbors, out uint[6] neighbor_indices) {

        const ivec4 pos_and_offset = shared_offset_table[cell_index];

        const uint right = get_transformed_index(pos_and_offset.xyz + ivec3(1,0,0));
        const uint left  = get_transformed_index(pos_and_offset.xyz + ivec3(-1,0,0));
        const uint up    = get_transformed_index(pos_and_offset.xyz + ivec3(0,1,0));
        const uint down  = get_transformed_index(pos_and_offset.xyz + ivec3(0,-1,0));
        const uint front = get_transformed_index(pos_and_offset.xyz + ivec3(0,0,1));
        const uint back  = get_transformed_index(pos_and_offset.xyz + ivec3(0,0,-1));

        neighbors[0] = shared_fmm_nodes[left + 160 * work_index]; // LEFT
        neighbors[1] = shared_fmm_nodes[right + 160 * work_index]; // RIGHT
        neighbors[2] = shared_fmm_nodes[down + 160 * work_index]; // DOWN
        neighbors[3] = shared_fmm_nodes[up + 160 * work_index]; // UP
        neighbors[4] = shared_fmm_nodes[back + 160 * work_index]; // BACK
        neighbors[5] = shared_fmm_nodes[front + 160 * work_index]; // FRONT

        neighbor_indices[0] = left + 160 * work_index;
        neighbor_indices[1] = right + 160 * work_index;
        neighbor_indices[2] = down + 160 * work_index;
        neighbor_indices[3] = up + 160 * work_index;
        neighbor_indices[4] = back + 160 * work_index;
        neighbor_indices[5] = front + 160 * work_index;
}

float solve_quadratic(uint cell_index) {

        // Band cell to be processed.
        FMM_Node node = shared_fmm_nodes[cell_index];

        // Surrounding neighbors.
        FMM_Node[6] neighbors;
        uint[6] neighbor_indices;

        get_neighbors(gl_LocalInvocationID.x, gl_LocalInvocationID.y, neighbors, neighbor_indices);

        // Best cell values in x-y-z directions. Values are calculated 
        // from known cell neighbors only.

        float phis[3] = {0.0, 0.0, 0.0};

        // Deltas. 
        float hs[3] = {0.0, 0.0, 0.0};

        //The grid x-length. ???
        //float h = 1.0;

        // X-DIRECTION

        // x dir.
        phis[0] = neighbors[0].tag == KNOWN && neighbors[1].tag == KNOWN ? min(neighbors[0].value, neighbors[1].value) : 0.0;
        phis[0] = neighbors[0].tag == KNOWN && neighbors[1].tag != KNOWN ? neighbors[0].value : phis[0];
        phis[0] = neighbors[0].tag != KNOWN && neighbors[1].tag == KNOWN ? neighbors[1].value : phis[0];

        // y dir.
        phis[1] = neighbors[2].tag == KNOWN && neighbors[3].tag == KNOWN ? min(neighbors[2].value, neighbors[3].value) : 0.0;
        phis[1] = neighbors[2].tag == KNOWN && neighbors[3].tag != KNOWN ? neighbors[2].value : phis[1];
        phis[1] = neighbors[2].tag != KNOWN && neighbors[3].tag == KNOWN ? neighbors[3].value : phis[1];

        // z dir.
        phis[2] = neighbors[4].tag == KNOWN && neighbors[5].tag == KNOWN ? min(neighbors[4].value, neighbors[5].value) : 0.0;
        phis[2] = neighbors[4].tag == KNOWN && neighbors[5].tag != KNOWN ? neighbors[4].value : phis[2];
        phis[2] = neighbors[4].tag != KNOWN && neighbors[5].tag == KNOWN ? neighbors[5].value : phis[2];

        if (phis[0] != 0.0) hs[0] = 1;
        if (phis[1] != 0.0) hs[1] = 1;
        if (phis[2] != 0.0) hs[2] = 1;

        float a = 0.0;
        float b = 0.0;
        float c = 0.0;

        for (int i=0 ; i<3 ; i++) {
            float oho = hs[i] * hs[i];
            a += oho;
            b += oho * phis[i];
            c += oho * phis[i] * phis[i];
        }
        b *= -2.0;

        c -= 1.0; // Speed function 1/(f_i,j,k)^2 

        float final_distance = 777.0;

        float discriminant = pow(b, 2.0) - (4.0*a*c);

        if (discriminant >= 0.0) {
            float t_phi = (-1.0*b + sqrt(discriminant)) / (2.0*a); 
            final_distance = t_phi;
            if (phis[0] < t_phi && phis[1] < t_phi && phis[2] < t_phi) {
                final_distance = t_phi;
            }
        }

        return final_distance;
}

// update band point values.
void update_band_points() {

}

// Prequisities: shared_fmm_nodes must be loaded (center).
void reduce(bool process) {
    shared_fmm_indices[gl_LocalInvocationIndex] = gl_LocalInvocationID.x;
    barrier();

    for (uint s = LOCAL_X_DIM/2 ; s > 0 ; s >>= 1) {
        if (gl_LocalInvocationID.x < s && process) {

                FMM_Node a = shared_fmm_nodes[shared_fmm_indices[gl_LocalInvocationIndex] + 160 * gl_LocalInvocationID.y];
                FMM_Node b = shared_fmm_nodes[shared_fmm_indices[gl_LocalInvocationIndex + s] + 160 * gl_LocalInvocationID.y];

                if (a.tag == BAND && b.tag == BAND) {
                    shared_fmm_indices[gl_LocalInvocationIndex] =
                        a.value < b.value ? shared_fmm_indices[gl_LocalInvocationIndex] : shared_fmm_indices[gl_LocalInvocationIndex + s];
                }

                // if (a.tag == BAND && b.tag != BAND) {
                //     shared_fmm_indices[gl_LocalInvocationIndex] = shared_fmm_indices[gl_LocalInvocationIndex]; // ???
                // }

                if (a.tag != BAND && b.tag == BAND) {
                    shared_fmm_indices[gl_LocalInvocationIndex] = shared_fmm_indices[gl_LocalInvocationIndex + s];
                    //shared_fmm_indices[thread_a] = shared_fmm_indices[thread_b];
                }

                // TODO: check if band tag.
                //shared_fmm_indices[gl_LocalInvocationIndex] =
                //    a.value < b.value ? shared_fmm_indices[gl_LocalInvocationIndex] : shared_fmm_indices[gl_LocalInvocationIndex + s];
        }
        barrier();
    }
}

const ivec3[33] neighbor_block_positions = {
    ivec3(0,0,0),  // Center   0  
    ivec3(0,0,-1), // Back     1 
    ivec3(0,0,1),  // Front    2 
    ivec3(0,0,0),  //          3 
    ivec3(1,0,0),  // Right    4
    ivec3(0,0,0),  //          5
    ivec3(0,0,0),  //          6
    ivec3(0,0,0),  //          7
    ivec3(-1,0,0), // Left     8
    ivec3(0,0,0),  //          9
    ivec3(0,0,0),  //          10
    ivec3(0,0,0),  //          11
    ivec3(0,0,0),  //          12
    ivec3(0,0,0),  //          13
    ivec3(0,0,0),  //          14
    ivec3(0,0,0),  //          15
    ivec3(0,-1,0), // Bottom   16
    ivec3(0,0,0),  //          17
    ivec3(0,0,0),  //          18
    ivec3(0,0,0),  //          19
    ivec3(0,0,0),  //          20
    ivec3(0,0,0),  //          21
    ivec3(0,0,0),  //          22
    ivec3(0,0,0),  //          23
    ivec3(0,0,0),  //          24
    ivec3(0,0,0),  //          25
    ivec3(0,0,0),  //          26
    ivec3(0,0,0),  //          27
    ivec3(0,0,0),  //          28
    ivec3(0,0,0),  //          29
    ivec3(0,0,0),  //          30
    ivec3(0,0,0),  //          31
    ivec3(0,1,0)   // Top      32 
};

int neighbor_block_index(uint hash_index, ivec3 block_pos) {

  uint result = 0;

  // Center.
  //result |= uint(hash_index >= 0 && hash_index < 64);

  // Back.
  result |= uint(hash_index >= 64 && hash_index < 80);

  // Front.
  result |= uint(hash_index >= 80 && hash_index < 96) << 1;

  // Right.
  result |= uint(hash_index >= 96 && hash_index < 112) << 2;

  // Left.
  result |= uint(hash_index >= 112 && hash_index < 128) << 3;

  // Bottom.
  result |= uint(hash_index >= 128 && hash_index < 144) << 4;

  // Up.
  result |= uint(hash_index >= 144 && hash_index < 160) << 5;

  // BlockData ijk = get_block_pos_index(block_index);
  // ivec3 neighbor_position = ijk.base_position + neighbor_block_positions[result]*4;

  ivec3 this_position = block_pos + neighbor_block_positions[result];

  //++ bool outside = this_position.x < 0 ||
  //++                this_position.y < 0 ||
  //++                this_position.z < 0 ||
  //++                this_position.x >= fmm_attributes.global_dimensions.x ||
  //++                this_position.y >= fmm_attributes.global_dimensions.y ||
  //++                this_position.z >= fmm_attributes.global_dimensions.z;
  
  uint new_block_index = this_position.x +
                         this_position.y * fmm_attributes.global_dimensions.x +  
                         this_position.z * fmm_attributes.global_dimensions.x * fmm_attributes.global_dimensions.y;

  //++ int final_block_index = outside ? -1 : int(new_block_index);

  //++ return final_block_index;
  return int(new_block_index);
}

void synchronize_fmm() {

    if (gl_LocalInvocationIndex == 0) {
        for (int i=0 ; i<shared_changed_fmm_counter; i++) {
            FMM_Block_Shared temp = shared_changed_fmm_info[i];
            //if (temp.block_index != -1) {

                uint old_tag = atomicMin(fmm_nodes[temp.global_index].tag, temp.tag);

                // A new band found. Increase band count by one.
                if (old_tag == FAR && temp.tag == BAND) {
                    //++ atomicAdd(fmm_block[temp.block_index].band_points_count, 1);

                    //++ vec3 this_coord = vec3(temp.global_pos);
                    //++ //vec3 this_coord = vec3(temp.global_pos);

                    //++ initialize_char_array(vec3(this_coord.x, this_coord.y, this_coord.z) + vec3(0.0,0.1,0.0));
    
                    //++ log_number(temp.block_index, false);
                    //++ add_end_of_line();
    
                    //++ AABB aabb = create_char_sequency_points(255, 255, 255);
                    //++ AABB traslated = AABB(vec4(this_coord, 1.0), vec4(this_coord + vec3(1.0, 1.0, 1.0), 1.0));
                    //++ create_output_points(aabb, 155, 255, 155);

                    //++ AABB jebulis = AABB(
                    //++     vec4(
                    //++         this_coord + vec3(-0.1, -0.1, -0.01),
                    //++         1.0),
                    //++     vec4(
                    //++         this_coord + vec3(0.25, 0.25, 0.0),
                    //++         1.0)
                    //++ );
                    //++ create_aabb_triangles_r(jebulis, 200, 100, 0, 0.01);
                }

                // A new known found. Decrease band count by one.
                if (old_tag == BAND && temp.tag == KNOWN) {
                    atomicAdd(fmm_block[temp.block_index].band_points_count, -1);

                     //++ vec3 this_coord = vec3(temp.global_pos);

                     //++ initialize_char_array( vec3(this_coord.x, this_coord.y, this_coord.z) + vec3(0.0,0.1,0.0));
    
                     //++ log_number(temp.block_index, false);
                     //++ add_end_of_line();
    
                     //++ AABB aabb = create_char_sequency_points(255, 255, 255);
                     //++ AABB traslated = AABB(vec4(this_coord, 1.0), vec4(this_coord + vec3(1.0, 1.0, 1.0), 1.0));
                     //++ create_output_points(aabb, 155, 255, 155);

                     //++ AABB jebulis = AABB(
                     //++     vec4(
                     //++         this_coord + vec3(-0.1, -0.1, -0.01),
                     //++         1.0),
                     //++     vec4(
                     //++         this_coord + vec3(0.25, 0.25, 0.0),
                     //++         1.0)
                     //++ );
                     //++ create_aabb_triangles_r(jebulis, 100, 200, 0, 0.02);
                }
            //}
        }
    }
    barrier();
}

bool is_outside(ivec3 pos) {

        return pos.x < 0 ||
               pos.y < 0 ||
               pos.z < 0 ||
               pos.x >= fmm_attributes.global_dimensions.x*4 ||
               pos.y >= fmm_attributes.global_dimensions.y*4 ||
               pos.z >= fmm_attributes.global_dimensions.z*4;
}

// Find smallest BAND point, change it to KNOWN point. TODO : Update neighbors to
// BAND points. Synchronize ghost points.
void find_smallest() {

    const uint offset =
        stream_compaction_count == 0 ? 0 : (stream_compaction_count - 1) / LOCAL_Y_DIM + 1;

    uint all_dimension_length = global_data_length();

    const uint last_index = stream_compaction_count + all_dimension_length;

    // Iterate over active blocks. Find smallest band node and change it to
    // known. Add surrounding not known nodes to band.
    for (int i=0 ; i<offset ; i++) {

      // Reset the syncronization fmm cell counter.
      if (gl_LocalInvocationIndex == 0) { shared_changed_fmm_counter = 0; }
      barrier();

      // Calculate the position of the current active block.
      const uint actual_block_index = i + offset * gl_LocalInvocationID.y + all_dimension_length;
      BlockData ijk = get_block_pos_index(fmm_block[actual_block_index].index);

      // Save block data to shared memory for syncronization purposes.
      //if (actual_block_index < last_index && gl_LocalInvocationID.x == 0) {
      //  shared_block_sync_info[gl_LocalInvocationID.y] = ijk;
      //}
      //barrier();

      // Load fmm blocks to shared memory. Load ghost region also. 
      if (actual_block_index < last_index) {
        load_fmm_data(ijk.base_index, ijk.base_position * 4, false);
      }
      barrier();

      // Find the smallest band value. Its local index can be found in shared_fmm_indices.
      reduce(actual_block_index < last_index);
      barrier();

      // Change the found band node to known and add to syncronize list.
      if (actual_block_index < last_index && gl_LocalInvocationID.x == 0) {

        const ivec4 data_index = shared_offset_table[shared_fmm_indices[gl_LocalInvocationIndex]];
        const uint global_index = data_index.w + ijk.base_index;
        const ivec3 global_pos = data_index.xyz + ijk.base_position*4;

        //if (is_outside(global_pos)) {
        //}
        // Data is inside computing context. TODO: this should be always true.
        //if (!is_outside(global_pos)) {
            uint block_base_index = ijk.base_position.x +
                                    ijk.base_position.y * fmm_attributes.global_dimensions.x +
                                    ijk.base_position.z * fmm_attributes.global_dimensions.x * fmm_attributes.global_dimensions.y;
            FMM_Block_Shared sync_data = FMM_Block_Shared(KNOWN, global_index, int(block_base_index), global_pos);
            uint index = atomicAdd(shared_changed_fmm_counter, 1);
            shared_changed_fmm_info[index] = sync_data;
        //}

        FMM_Node[6] neighbors;
        uint[6] neighbor_indices;

        get_neighbors(data_index.w, gl_LocalInvocationID.y, neighbors, neighbor_indices);
        //get_neighbors(data_index.w, 0, neighbors, neighbor_indices);

        for (int i=0 ; i<6; i++) {

            const uint basic_hash_index = neighbor_indices[i] - 160 * gl_LocalInvocationID.y;
            //const uint basic_hash_index = neighbor_indices[i];
            const ivec4 data_ind = shared_offset_table[basic_hash_index];
            const uint global_ind = data_ind.w + ijk.base_index;
            const ivec3 global_p = data_ind.xyz + ijk.base_position*4;

            // The neighbor data is inside computing context.
            if (!is_outside(global_p)) {
                FMM_Block_Shared sync_d = FMM_Block_Shared(BAND, global_ind, neighbor_block_index(basic_hash_index, ijk.base_position),global_p);
                uint ind = atomicAdd(shared_changed_fmm_counter, 1);
                shared_changed_fmm_info[ind] = sync_d;

                //log int new_base_index = neighbor_block_index(basic_hash_index, ijk.base_position);
                //log BlockData new_block_data = get_block_pos_index(new_base_index);

                //log vec3 this_coord = vec3(new_block_data.base_position*4);
                //log initialize_char_array( vec3(this_coord.x, this_coord.y, this_coord.z));
    
                //log log_number(data_ind.w, false);
                //log add_end_of_line();
    
                //log AABB aabb = create_char_sequency_points(255, 255, 255);
                //log AABB traslated = AABB(vec4(this_coord, 1.0), vec4(this_coord + vec3(4.0, 4.0, 4.0), 1.0));
                //log create_output_points(aabb, 155, 255, 155);

                //log AABB jebulis = AABB(
                //log     vec4(
                //log         this_coord,
                //log         1.0),
                //log     vec4(
                //log         this_coord + vec3(4.0), 1.0));
                //log create_aabb_triangles_r(jebulis, 255, 255, 0, 0.05);
            }
            //logelse {

            //log    int new_base_index = neighbor_block_index(basic_hash_index, ijk.base_position);
            //log    BlockData new_block_data = get_block_pos_index(new_base_index);

            //log    vec3 this_coord = vec3(global_p);
            //log    initialize_char_array( vec3(this_coord.x, this_coord.y, this_coord.z));
    
            //log    log_vec3(global_p, 1);
            //log    add_end_of_line();
    
            //log    AABB aabb = create_char_sequency_points(255, 255, 255);
            //log    AABB traslated = AABB(vec4(this_coord, 1.0), vec4(this_coord + vec3(1.0, 1.0, 1.0), 1.0));
            //log    create_output_points(aabb, 155, 255, 155);

            //log    AABB jebulis = AABB(
            //log        vec4(
            //log            this_coord,
            //log            1.0),
            //log        vec4(
            //log            this_coord + vec3(1.0), 1.0));
            //log    create_aabb_triangles_r(jebulis, 255, 255, 0, 0.05);
            //log}
        } // for
      } // if

      barrier();
      synchronize_fmm();
      //barrier();
    } // for
}

void add_initial_band_points() {

  uint global_dimension_length = global_data_length();

  // Create BAND points to the inital initial interface.

  const uint offset = global_dimension_length/LOCAL_Y_DIM;

  for (int b = 0; b<offset ; b++) {

        BlockData ijk = get_block_pos_index(b + offset * gl_LocalInvocationID.y);

        // Load FMM nodes to the shared memory.
        load_fmm_data(ijk.base_index, ijk.base_position * 4, false);
        barrier();

        FMM_Node node = shared_fmm_nodes[gl_LocalInvocationID.x + 160 * gl_LocalInvocationID.y];

        // Create BAND points.
        if (node.tag == KNOWN) {

            FMM_Node[6] neighbors;
            uint[6] neighbor_indices;
            get_neighbors(gl_LocalInvocationID.x, gl_LocalInvocationID.y, neighbors, neighbor_indices);

            // TODO: out side of context fmm nodes.

            bool add_band = neighbors[0].tag != KNOWN;
            
            if (add_band) {
                shared_fmm_nodes[neighbor_indices[0]].tag = BAND;
            }

            shared_fmm_nodes[neighbor_indices[0]].tag =  
                neighbors[0].tag != KNOWN ? BAND : shared_fmm_nodes[neighbor_indices[0]].tag;

            shared_fmm_nodes[neighbor_indices[1]].tag =  
                neighbors[1].tag != KNOWN ? BAND : shared_fmm_nodes[neighbor_indices[1]].tag;

            shared_fmm_nodes[neighbor_indices[2]].tag =  
                neighbors[2].tag != KNOWN ? BAND : shared_fmm_nodes[neighbor_indices[2]].tag;

            shared_fmm_nodes[neighbor_indices[3]].tag =  
                neighbors[3].tag != KNOWN ? BAND : shared_fmm_nodes[neighbor_indices[3]].tag;

            shared_fmm_nodes[neighbor_indices[4]].tag =  
                neighbors[4].tag != KNOWN ? BAND : shared_fmm_nodes[neighbor_indices[4]].tag;

            shared_fmm_nodes[neighbor_indices[5]].tag =  
                neighbors[5].tag != KNOWN ? BAND : shared_fmm_nodes[neighbor_indices[5]].tag;
        }

        barrier();

        // Update both center data and ghost region band points.
        save_fmm_data(ijk.base_index, ijk.base_position * 4, false);

        barrier();

  } // for
}

void render_fmm_nodes() {

  uint all_dimension_length = global_data_length();

  const uint offset =
      stream_compaction_count == 0 ? 0 : (all_dimension_length - 1) / LOCAL_Y_DIM + 1;

  for (int b = 0; b<offset ; b++) {

    uint block_index = b + gl_LocalInvocationID.y * offset;

    BlockData ijk = get_block_pos_index(block_index);

    // Load FMM nodes to the shared memory.
    load_fmm_data(ijk.base_index, ijk.base_position * 4, false);
    barrier();

    if (block_index < all_dimension_length) {

        const uvec3 known = uvec3(0,200,0);
        const uvec3 band = uvec3(200,0,0);
        const uvec3 band_new = uvec3(200,200,0);
        const uvec3 far = uvec3(0,0,200);
        const uvec3 new_band = uvec3(185,130,130);
        const uvec3 error = uvec3(255,0,255);
        
        uvec3 final_color = uvec3(255,255,255);

        vec3 this_coord = vec3(shared_offset_table[gl_LocalInvocationID.x].xyz + ijk.base_position * 4);
        FMM_Node node = shared_fmm_nodes[gl_LocalInvocationID.x + 160 * gl_LocalInvocationID.y];

        if (node.tag == FAR) { final_color = far; }
        if (node.tag == BAND) { final_color = band; }
        if (node.tag == KNOWN) { final_color = known; }
        if (node.value == 777.0) { final_color = error; }

        create_point_ball7(this_coord, final_color.x,final_color.y,final_color.z, 0.01);
    }
    barrier();
  } // for
}

void solve_quadradic_band_points() {

  uint all_dimension_length = global_data_length();

  const uint last_index = stream_compaction_count + all_dimension_length;
  const uint offset = (stream_compaction_count - 1) / LOCAL_Y_DIM + 1;

  for (int b = 0; b<offset ; b++) {

    const uint actual_block_index = b + offset * gl_LocalInvocationID.y + all_dimension_length;
    BlockData ijk = get_block_pos_index(fmm_block[actual_block_index].index);

    // Load fmm blocks to shared memory. Load ghost region also. 
    if (actual_block_index < last_index) {
      load_fmm_data(ijk.base_index, ijk.base_position * 4, false);
    }
    barrier();

    FMM_Node node = shared_fmm_nodes[gl_LocalInvocationID.x + 160 * gl_LocalInvocationID.y];

    // BAND found.
    if (node.tag == BAND && actual_block_index < last_index) {
        node.value = solve_quadratic(gl_LocalInvocationID.x + 160 * gl_LocalInvocationID.y);
        shared_fmm_nodes[gl_LocalInvocationID.x + 160 * gl_LocalInvocationID.y] = node; 
    }
    barrier();

    // Update both center data and ghost region band points.
    if (actual_block_index < last_index) { save_fmm_data(ijk.base_index, ijk.base_position * 4, true); }
    barrier();
  }
}

void calculate_initial_band_count() {
    
  uint all_dimension_length = global_data_length();

  const uint offset = (all_dimension_length - 1) / LOCAL_Y_DIM + 1;
  // TODO: offset might not be correct.

  for (int b = 0; b<offset ; b++) {

    uint block_index = b + gl_LocalInvocationID.y * offset;
    bool process = block_index < all_dimension_length;

    BlockData ijk = get_block_pos_index(block_index);

    // Load FMM nodes to the shared memory.

    if (gl_LocalInvocationID.x == 0) { band_counts[gl_LocalInvocationID.y] = 0; }
    barrier();

    if (process) { load_fmm_data(ijk.base_index, ijk.base_position * 4, false); }
    barrier();

    FMM_Node node = shared_fmm_nodes[gl_LocalInvocationID.x + 160 * gl_LocalInvocationID.y];

    // BAND found.
    if (node.tag == BAND && process) {
        atomicAdd(band_counts[gl_LocalInvocationID.y], 1);
        node.value = solve_quadratic(gl_LocalInvocationID.x + 160 * gl_LocalInvocationID.y);
        //node.tag = BAND;
        shared_fmm_nodes[gl_LocalInvocationID.x + 160 * gl_LocalInvocationID.y] = node; 
    }
    barrier();

    // Update both center data and ghost region band points.
    if (process) { save_fmm_data(ijk.base_index, ijk.base_position * 4, true); }
    barrier();

    // Update band point count to the corresponding FMM_Block.
    if (gl_LocalInvocationID.x == 0 && process) {
        fmm_block[block_index].band_points_count = band_counts[gl_LocalInvocationID.y];
    }
    barrier();
  }
}

void render_block(uint b, bool ghost_zone) {

    // TODO: Implement ghost_zone visualization?

    BlockData ijk = get_block_pos_index(fmm_block[b].index);
    
    vec3 this_coord = vec3(shared_offset_table[gl_LocalInvocationID.x].xyz + ijk.base_position * 4);
    FMM_Node fmm_b = shared_fmm_nodes[gl_LocalInvocationID.x + 160 * gl_LocalInvocationID.y];
    
    const uvec3 known = uvec3(0,200,0);
    const uvec3 band = uvec3(200,0,0);
    const uvec3 band_new = uvec3(200,200,0);
    const uvec3 far = uvec3(0,0,200);
    const uvec3 new_band = uvec3(185,130,130);
    const uvec3 error = uvec3(255,0,255);
    
    uvec3 final_color = uvec3(255,255,255);
    
    if (fmm_b.tag == FAR) { final_color = far; }
    if (fmm_b.tag == BAND) { final_color = band; }
    if (fmm_b.tag == KNOWN) { final_color = known; }
    //if (fmm_b.tag == KNOWN_NEW) { final_color = band_new; }
    if (fmm_b.value == 777.0) { final_color = error; }
    
    //if (fmm_b.tag != FAR) { 
    if (fmm_b.tag == BAND || fmm_b.tag == KNOWN) { 
    //if (fmm_b.tag == BAND || fmm_b.tag == KNOWN_NEW || fmm_b.tag == NEW_BAND || fmm_b.tag == KNOWN) { 
    //if (fmm_b.tag == KNOWN_NEW) { 

        create_point_ball7(this_coord, final_color.x,final_color.y,final_color.z, 0.01);

        //++   initialize_char_array(
        //++     vec3(this_coord.x,
        //++          this_coord.y,
        //++          this_coord.z));
    
        //++   // log_vec3(vec3(this_coord), 1);
        //++   // add_end_of_line();
        //++   //log_number(123, false);
        //++   // log_number(position_index, false);
        //++   log_float(fmm_b.value, 2);
        //++   //log_float(fmm_block[b].band_points_count, 2);
        //++   //log_number(b - global_data_length(), false);
        //++   //log_number(stream_compaction_count, false);
        //++   add_end_of_line();
        //++   ////  log_number(shared_vec_to_offset[thread_id], false);
        //++   //++log_number(mapping_to_offset, false);
        //++   //++add_end_of_line();
    
        //++   ////++ log_vec3(vec3(this_coord), 1);
        //++   ////++ add_end_of_line();
        //++   ////++ //log_number(123, false);
        //++   ////++ log_number(thread_id, false);
        //++   ////++ //log_number(joopajoo.index, false);
        //++   ////++ add_end_of_line();
        //++   ////++ ////  log_number(shared_vec_to_offset[thread_id], false);
        //++   ////++ log_number(joopajoo.index, false);
        //++   ////++ add_end_of_line();
    
    
        //++   // if (thread_id < 64) { final_color = center_color; }
        //++   // else if (in_domain) { final_color = ghost_color; }
        //++   // else { final_color = outside_color; }
    
        //++   AABB aabb = create_char_sequency_points(final_color.x, final_color.y, final_color.z);
        //++   AABB traslated = AABB(vec4(this_coord, 1.0), vec4(this_coord + vec3(1.0, 1.0, 1.0), 1.0));
        //++   create_output_points(aabb, final_color.x, final_color.y, final_color.z);

        //shared_memory_nodes[thread_id] = thread_id < 160 ?
    }

    if (gl_LocalInvocationID.x == 0) {

        const float border_width = 0.05;

        initialize_char_array(vec3(ijk.base_position * 4 - vec3(0.5)));
    
        //log_float(fmm_block[b].band_points_count, 2);
        log_float(fmm_block[b].band_points_count,1);
        add_end_of_line();
                                                                 
        AABB aabb_joo = create_char_sequency_points(222, 222, 222);
        AABB traslated_joo = AABB(vec4(this_coord - vec3(0.5), 1.0),
                             vec4(this_coord - vec3(0.5) + vec3(1.0, 1.0, 1.0), 1.0));
        create_output_points(aabb_joo, 22, 22, 22);
                                 
        AABB jebulis = AABB(vec4(vec3(ijk.base_position) * 4 -
        vec3(0.5 + border_width*0.5), 1.0), vec4(vec3(ijk.base_position) * 4 + vec3(3.5 + border_width*0.5), 1.0));
        create_aabb_triangles_r(jebulis, 255, 50, 255, border_width);
    }
    // if (gl_LocalInvocationID.x == 1) {
    //     if (b - global_data_length() == 0) {
    //         initialize_char_array(vec3(-5,-5,5));
    // 
    //         log_vec3(vec3(ijk.base_position), 1);
    //         add_end_of_line();
    //     AABB aabb = create_char_sequency_points(255, 255, 255);
    //     AABB traslated = AABB(vec4(vec3(-5,-5,5), 1.0), vec4(vec3(-5,-5,5) + vec3(1.0, 1.0, 1.0), 1.0));
    //     create_output_points(aabb, 100, 100, 100);
    //     //    AABB jebulis = AABB(vec4(vec3(-5,-5,5) - vec3(0.5), 1.0), vec4(vec3(-5,-5,5) * 4 + vec3(3.5, 3.5, 3.5), 1.0));
    //     //    create_aabb_triangles_r(jebulis, 255, 255, 255, 0.05);
    //     }
    // }
}

void main() {

  /* LOAD COUNTERS. DEBUGGING. */
  if (local_id_to_x() == 0) {
    counter[0] = atomic_counters[0];
    counter[1] = atomic_counters[1];

    /* RENDER THE GLOBAL AABB. */
    AABB scene_aabb = AABB(vec4(-0.15, -0.15, 0.15, 1.0),
                           vec4(fmm_attributes.global_dimensions.x * 4,
                                fmm_attributes.global_dimensions.y * 4,
                                fmm_attributes.global_dimensions.z * 4,
                                1.0) + vec4(0.15, 0.15, -0.15, 0.0));
    create_aabb_triangles_r(scene_aabb,
                      150,
                      100,
                      100,
                      0.15
    );
  }


  /* LOAD HASH TABLES TO SHARED MEMORY. */

  load_offset_hash_table(); // OK?
  load_vec_to_offset(); // OK?
  //groupMemoryBarrier();
  barrier();

  /* CREATE FIRST BAND FOR INITIAL FMM NODES. */
  if (fmm_attributes.current_block[0] == 0) {
    add_initial_band_points();
    barrier();

    calculate_initial_band_count();
    barrier();
  }

  global_solver();
  barrier();

  find_smallest();
  barrier();

  // global_solver();
  // barrier();

  //++  solve_quadradic_band_points();
  //++  barrier();
  // global_solver();
  // barrier();

  // find_smallest();
  // barrier();

  // do {
  //   global_solver();
  //   barrier();

  //   if (stream_compaction_count > 0) {
  //       find_smallest();
  //       barrier();
  //   }
  // } while (stream_compaction_count > 0);
  
  //while (stream_compaction_count > 0) {
  //  global_solver();
  //  barrier();
  //  
  //  // Itetare active blocks. Add smallest value to KNOWN, update neighbors to
  //  // band. Points. Update band those band points. 

  //}

  /* RENDER NODES. DEBUGGING. */
  render_fmm_nodes();
  barrier();

  // uint all_dimension_length = global_data_length();

  // uint last_index = all_dimension_length + stream_compaction_count;

  // const uint offset = stream_compaction_count == 0 ? 0 : (stream_compaction_count - 1) / LOCAL_Y_DIM + 1;

  // for (int i=0 ; i<stream_compaction_count ; i += LOCAL_Y_DIM) {

  //   uint actual_index = gl_LocalInvocationID.y + i + all_dimension_length;

  //   BlockData ijk = get_block_pos_index(fmm_block[actual_index].index);

  //   // Load FMM nodes to the shared memory.
  //   if (actual_index < last_index) {
  //       load_fmm_data(ijk.base_index, ijk.base_position * 4, false);
  //   }
  //   barrier();

  //   if (actual_index < last_index) {
  //       render_block(actual_index, false);
  //   }
  //   barrier();
  // }
  //  check_all_threads();
  /* UPDATE COUNTERS. DEBUGGING. */
  if (local_id_to_x() == 0) {
    atomic_counters[0] = counter[0];
    atomic_counters[1] = counter[1];
  }
}

// NOTES:TODO
// Create blocks in kernel.

#version 450

#define MAX_NUM_CHARS 2 // 32 

#define LOCAL_X_DIM 64 
#define LOCAL_Y_DIM 16 
#define LOCAL_Z_DIM 1
//#define LOCAL_X_DIM 4 
//#define LOCAL_Y_DIM 4
//#define LOCAL_Z_DIM 4
#define GLOBAL_DIM_X 3
#define GLOBAL_DIM_Y 3
#define GLOBAL_DIM_Z 3
#define INDEX_OFFSET_Z (64 * GLOBAL_DIM_X * GLOBAL_DIM_Y - 48)
#define INDEX_OFFSET_Y (64 * GLOBAL_DIM_X - 12)
#define INDEX_OFFSET_X 61
#define THREAD_COUNT (LOCAL_X_DIM * LOCAL_Y_DIM * LOCAL_Z_DIM)
#define SCAN_BLOCK_SIZE (THREAD_COUNT * 2 + (THREAD_COUNT * 2 >> 4)) //136 // 128 + (128 >> 4)
#define ACTIVE_FMM_BLOCKS_OFFSET 512 // TODO: from uniform

// Fast marching method cell node.
// 0 => Far.
// 1 => Band.
// 2 => Known.
// 5 => Out of context.
struct FMM_Node {
    float value;
    uint tag;
};

//shared FMM_Node[160] shared_fmm_nodes;
shared FMM_Node[160*LOCAL_Y_DIM] shared_fmm_nodes;

// Load from application.
shared ivec4[160] shared_offset_table;
shared uint[216] shared_vec_to_offset;

#define DEBUG_OFFSET 0.07

struct FMM_Block {
    uint index;
    uint band_points_count;
};

//struct FMM_Block {
//    bool has_band_points;
//};

struct OutputVertex {
    vec3 pos;
    uint color_point_size;
};

struct AABB {
    vec4 min;
    vec4 max; 
};

layout(set=0, binding=0) uniform camerauniform {
    mat4 u_view_proj;
    vec4 camera_pos;
};

// This buffer holds the temporary prefix sum data.
layout(set = 0, binding = 1) buffer Prefix_sums {
    uint[] temp_prefix_sum;
};

layout(set = 0, binding = 2) buffer Points_out {
    OutputVertex[] output_points;
};

layout(set = 0, binding = 3) buffer FMM_Nodes {
    FMM_Node[] fmm_nodes;
};

// This buffer is divided to two parts.
// The first part includes the actual FMM_Blocks.
// The second part includes the active FMM_Blocks.
layout(set = 0, binding = 4) buffer FMM_Blocks {
    FMM_Block[] fmm_block;
};

layout(set = 0, binding = 5) buffer Counters {
    uint[2] atomic_counters;
};

layout(set = 0, binding = 6) readonly buffer OffsetTable {
    ivec4[160] offset_hash_table;
};

layout(set = 0, binding = 7) readonly buffer VecToHashTable {
    uint[216] vec_to_offset_table;
};

struct FMM_Attribute {
    uvec3 global_dimensions;
    uint offset_hash_table_size;
    uvec3 current_block;
    uint vec_to_offset_table_size;
};

layout(set=0, binding=8) uniform FMM_Attributes {
    FMM_Attribute fmm_attributes;
};

layout(local_size_x = LOCAL_X_DIM, local_size_y = LOCAL_Y_DIM, local_size_z = LOCAL_Z_DIM) in;

const float FONT_SIZE = 0.02;
const float FONT_OFFSET_Y = 1.2;
const uint MAX_NUM_OF_POINTS = 150;

//// Super clever hack to avoid if :).
const uint blah[2] = {0, 0xffffffff};

uint local_id_to_x() { return gl_LocalInvocationID.x + LOCAL_X_DIM * gl_LocalInvocationID.y + LOCAL_X_DIM * LOCAL_Z_DIM * gl_LocalInvocationID.z; }

struct Thread_id_info {
    uint group;
};

const uint[10] joo = {1,
                      10,
                      100,
                      1000,
                      10000,
                      100000,
                      1000000,
                      10000000,
                      100000000,
                      1000000000};

struct CharInformation {
    uint counter;
    vec3 position;
    uint[MAX_NUM_CHARS] chars;
};

// 2 x float
shared uint[2] counter;

// 136 x float
// The auxiliar scan block array
shared uint shared_aux[SCAN_BLOCK_SIZE];

// 136 x float
// The output of global active fmm block scan.
shared uint[SCAN_BLOCK_SIZE] shared_prefix_sum;

//// The counter for active fmm blocks.
shared uint stream_compaction_count;

// TODO: define a buffer for active scan blocks.
//shared FMM_Block[SCAN_BLOCK_SIZE * SCAN_BLOCK_COUNT] shared_stream_compaction;

// Debugging.
shared CharInformation[THREAD_COUNT] char_arrays;

const uvec3 local_dimension = uvec3(4,4,4);
const uvec3 group_dimension = uvec3(4,4,4);

const uint bez_indices[17] = {
    104| (108 << 8) | (112 << 16) | (116 << 24),  // 0       
    4  | (8 << 8) | (12 << 16) | (255 << 24),     // 1       
    16 | (20 << 8) | (24 << 16) | (255 << 24),    // 2       
    28 | (32 << 8) | (255 << 16) | (255 << 24),   // 3       
    36 | (40 << 8) | (44 << 16) | (255 << 24),    // 4       
    48 | (52 << 8) | (56 << 16) | (255 << 24),    // 5       
    60 | (64 << 8) | (68 << 16) | (255 << 24),    // 6       
    48 | (72 << 8) | (255 << 16) | (255 << 24),   // 7       
    76 | (80 << 8) | (84 << 16) | (88 << 24),     // 8       
    92 | (96 << 8) | (100 << 16) | (255 << 24),   // 9       
    0  | (255 << 8) | (255 << 16) | (255 << 24),  // 10
    104 | (112 << 8) | (255 << 16) | (255 << 24), // 11
    108 | (116 << 8) | (255 << 16) | (255 << 24), // 12
    148 | (152 << 8) | (156 << 16) | (160 << 24), // 13
    120 | (124 << 8) | (128 << 16) | (132 << 24), // 14
    136 | (140 << 8) | (144 << 16) | (255 << 24), // 15
    255 | (255 << 8) | (255 << 16) | (255 << 24), // 16
};

const vec4 bez_table[164] = {
    // Bez minus. 
    vec4(0.3, 0.5, 0.0, 0.25),     // 0
    vec4(0.433333, 0.5, 0.0, 0.0), // 1
    vec4(0.566666, 0.5, 0.0, 0.0), // 2
    vec4(0.7, 0.5, 0.0, 0.0),      // 3 

    // Bez 1.
    vec4(0.3, 0.1, 0.0, 4.0/14.0), // 4
    vec4(0.433333, 0.1, 0.0, 0.0), // 5
    vec4(0.566666, 0.1, 0.0, 0.0), // 6
    vec4(0.7, 0.1, 0.0, 0.0),      // 7 
    vec4(0.5, 0.1, 0.0, 8.0/14.0), // 8
    vec4(0.5, 0.366666, 0.0, 0.0), // 9
    vec4(0.5, 0.633333, 0.0, 0.0), // 10 
    vec4(0.5, 0.9, 0.0, 0.0),      // 11 
    vec4(0.5, 0.9, 0.0, 2.0/14.0), // 12 
    vec4(0.4, 0.8, 0.0, 0.0),      // 13 
    vec4(0.35, 0.8, 0.0, 0.0),     // 14 
    vec4(0.3, 0.8, 0.0, 0.0),      // 15 

    // Bez 2.
    vec4(0.3, 0.1, 0.0, 5.0/15.0),  // 16 
    vec4(0.433333, 0.1, 0.0, 0.0),  // 17 
    vec4(0.566666, 0.1, 0.0, 0.0),  // 18 
    vec4(0.7, 0.1, 0.0, 0.0),       // 19 
    vec4(0.3, 0.1, 0.0, 5.5/15.0),  // 20 
    vec4(0.416666, 0.3, 0.0, 0.0),  // 21 
    vec4(0.533333, 0.4, 0.0, 0.0),  // 22
    vec4(0.65, 0.55, 0.0, 0.0),     // 23 
    vec4(0.65, 0.55, 0.0, 6.5/15.0),// 24 
    vec4(0.8, 0.7, 0.0, 0.0),       // 25
    vec4(0.55, 1.08, 0.0, 0.0),     // 26
    vec4(0.3, 0.8, 0.0, 0.0),       // 27

    // Number 3
    vec4(0.3, 0.8, 0.0, 0.5),      // 28
    vec4(0.5, 1.1, 0.0, 0.0),      // 29
    vec4(0.95, 0.7, 0.0, 0.0),     // 30
    vec4(0.45, 0.55, 0.0, 0.0),    // 31
    vec4(0.45, 0.55, 0.0, 0.5),    // 32
    vec4(1.0, 0.45, 0.0, 0.0),     // 33
    vec4(0.5, -0.15, 0.0, 0.0),    // 34
    vec4(0.3, 0.2, 0.0, 0.0),      // 35

    // Number 4
    vec4(0.6, 0.1, 0.0, 8.0/17.0),   // 36
    vec4(0.6, 0.3666666, 0.0, 0.0),  // 37
    vec4(0.6, 0.6333333, 0.0, 0.0),  // 38
    vec4(0.6, 0.9, 0.0, 0.0),        // 39
    vec4(0.6, 0.9, 0.0, 5.0/17.0),   // 40
    vec4(0.466666, 0.75, 0.0, 0.0),  // 41
    vec4(0.333333, 0.6, 0.0, 0.0),   // 42
    vec4(0.2, 0.45, 0.0, 0.0),       // 43
    
    vec4(0.2, 0.45, 0.0, 4.0/17.0),  // 44
    vec4(0.3666666, 0.45, 0.0, 0.0), // 45
    vec4(0.5333333, 0.45, 0.0, 0.0), // 46
    vec4(0.7, 0.45, 0.0, 0.0),       // 47
    
    // Number 5.
    vec4(0.3, 0.9, 0.0, 2.0/13.0),  // 48
    vec4(0.433333, 0.9, 0.0, 0.0),  // 49
    vec4(0.566666, 0.9, 0.0, 0.0),  // 50
    vec4(0.7, 0.9, 0.0, 0.0),       // 51
    vec4(0.3, 0.5, 0.0, 2.0/13.0),  // 52
    vec4(0.3, 0.633333, 0.0, 0.0),  // 53
    vec4(0.3, 0.766666, 0.0, 0.0),  // 54
    vec4(0.3, 0.9, 0.0, 0.0),       // 55
    vec4(0.3, 0.5, 0.0, 9.0/13.0),  // 56
    vec4(1.0, 0.75, 0.0, 0.0),      // 57
    vec4(0.7, -0.2, 0.0, 0.0),      // 58
    vec4(0.3, 0.2, 0.0, 0.0),       // 59

    // Number 6
    vec4(0.7, 0.8, 0.0, 5.0/21.0),  // 60
    vec4(0.5, 1.05, 0.0, 0.0),      // 61
    vec4(0.3, 0.8, 0.0, 0.0),       // 62
    vec4(0.3, 0.5, 0.0, 0.0),       // 63
    vec4(0.3, 0.5, 0.0, 9.0/21.0),  // 64
    vec4(0.3, -0.05, 0.0, 0.0),     // 65
    vec4(0.7, 0.0, 0.0, 0.0),       // 66
    vec4(0.72, 0.4, 0.0, 0.0),      // 67
    vec4(0.72, 0.4, 0.0, 5.0/21.0), // 68
    vec4(0.72, 0.6, 0.0, 0.0),      // 69
    vec4(0.5, 0.7, 0.0, 0.0),       // 70
    vec4(0.3, 0.5, 0.0, 0.0),       // 71
    
    // Number 7 .
    // five_bez_a
    vec4(0.4, 0.1, 0.0, 6.0/13.0), // 72
    vec4(0.5, 0.366666, 0.0, 0.0), // 73
    vec4(0.6, 0.633333, 0.0, 0.0), // 74
    vec4(0.7, 0.9, 0.0, 0.0),      // 75
    
    
    // Number 8
    vec4(0.5, 0.9, 0.0, 0.25), // 76
    vec4(0.2, 0.85, 0.0, 0.0), // 77
    vec4(0.2, 0.55, 0.0, 0.0), // 78
    vec4(0.5, 0.5, 0.0, 0.0),  // 79
    vec4(0.5, 0.9, 0.0, 0.25), // 80
    vec4(0.8, 0.85, 0.0, 0.0), // 81
    vec4(0.8, 0.55, 0.0, 0.0), // 82
    vec4(0.5, 0.5, 0.0, 0.0),  // 83
    vec4(0.5, 0.1, 0.0, 0.25), // 84
    vec4(0.8, 0.15, 0.0, 0.0), // 85
    vec4(0.8, 0.45, 0.0, 0.0), // 86
    vec4(0.5, 0.5, 0.0, 0.0),  // 87
    vec4(0.5, 0.1, 0.0, 0.25), // 88
    vec4(0.2, 0.15, 0.0, 0.0), // 89
    vec4(0.2, 0.45, 0.0, 0.0), // 90
    vec4(0.5, 0.5, 0.0, 0.0),  // 91
    
    // Number 9
    vec4(0.3, 0.2, 0.0, 8.0/20.0), // 92
    vec4(0.5, -0.05, 0.0, 0.0),    // 93
    vec4(0.7, 0.2, 0.0, 0.0),      // 94
    vec4(0.7, 0.6, 0.0, 0.0),      // 95
    vec4(0.7, 0.6, 0.0, 6.0/20.0), // 96
    vec4(0.7, 0.95, 0.0, 0.0),     // 97
    vec4(0.4, 1.0, 0.0, 0.0),      // 98
    vec4(0.28, 0.8, 0.0, 0.0),     // 99
    vec4(0.28, 0.8, 0.0, 6.0/20.0),// 100
    vec4(0.1, 0.4, 0.0, 0.0),      // 101
    vec4(0.6, 0.4, 0.0, 0.0),      // 102
    vec4(0.7, 0.6, 0.0, 0.0),      // 103
    
    // Number 0 
    vec4(0.5, 0.9, 0.0, 0.25),   // 104
    vec4(0.25, 0.85, 0.0, 0.0),  // 105
    vec4(0.25, 0.55, 0.0, 0.0),  // 106
    vec4(0.25, 0.5, 0.0, 0.0),   // 107
    vec4(0.5, 0.9, 0.0, 0.25),   // 108
    vec4(0.75, 0.85, 0.0, 0.0),  // 109
    vec4(0.75, 0.55, 0.0, 0.0),  // 110
    vec4(0.75, 0.5, 0.0, 0.0),   // 111
    vec4(0.5, 0.1, 0.0, 0.25),   // 112
    vec4(0.25, 0.15, 0.0, 0.0),  // 113
    vec4(0.25, 0.45, 0.0, 0.0),  // 114
    vec4(0.25, 0.5, 0.0, 0.0),   // 115
    vec4(0.5, 0.1, 0.0, 0.25),   // 116
    vec4(0.75, 0.15, 0.0, 0.0),  // 117
    vec4(0.75, 0.45, 0.0, 0.0),  // 118
    vec4(0.75, 0.5, 0.0, 0.0),   // 119
    
    // Number inf 
    vec4(0.5, 0.5, 0.0, 0.25),   // 120
    vec4(0.4, 0.7, 0.0, 0.0),    // 121
    vec4(0.2, 0.7, 0.0, 0.0),    // 122
    vec4(0.1, 0.5, 0.0, 0.0),    // 123  
    vec4(0.1, 0.5, 0.0, 0.25),   // 124
    vec4(0.2, 0.3, 0.0, 0.0),    // 125
    vec4(0.4, 0.3, 0.0, 0.0),    // 126
    vec4(0.5, 0.5, 0.0, 0.0),    // 127  
    vec4(0.5, 0.5, 0.0, 0.25),   // 128
    vec4(0.6, 0.7, 0.0, 0.0),    // 129
    vec4(0.8, 0.7, 0.0, 0.0),    // 130
    vec4(0.9, 0.5, 0.0, 0.0),    // 131  
    vec4(0.9, 0.5, 0.0, 0.25),   // 132
    vec4(0.8, 0.3, 0.0, 0.0),    // 133
    vec4(0.6, 0.3, 0.0, 0.0),    // 134
    vec4(0.5, 0.5, 0.0, 0.0),    // 135  
    
    // Nan
    vec4(0.2, 0.1, 0.0, 8.0/26.0), // 136
    vec4(0.2, 0.366666, 0.0, 0.0), // 137
    vec4(0.2, 0.633333, 0.0, 0.0), // 138
    vec4(0.2, 0.9, 0.0, 0.0),      // 139
    
    vec4(0.2, 0.9, 0.0, 10.0/26.0),// 140
    vec4(0.4, 0.633333, 0.0, 0.0), // 141
    vec4(0.6, 0.366666, 0.0, 0.0), // 142
    vec4(0.8, 0.1, 0.0, 0.0),      // 143
    
    vec4(0.8, 0.1, 0.0, 8.0/26.0), // 144
    vec4(0.8, 0.366666, 0.0, 0.0), // 145
    vec4(0.8, 0.633333, 0.0, 0.0), // 146
    vec4(0.8, 0.9, 0.0, 0.0),      // 147

    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.5, 0.9, 0.0, 0.15)),   // 148
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.25, 0.85, 0.0, 0.0)),  // 149
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.25, 0.55, 0.0, 0.0)),  // 150
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.25, 0.5, 0.0, 0.0)),   // 151
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.5, 0.9, 0.0, 0.15)),   // 152
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.75, 0.85, 0.0, 0.0)),  // 153
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.75, 0.55, 0.0, 0.0)),  // 154
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.75, 0.5, 0.0, 0.0)),   // 155
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.5, 0.1, 0.0, 0.15)),   // 156
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.25, 0.15, 0.0, 0.0)),  // 157
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.25, 0.45, 0.0, 0.0)),  // 158
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.25, 0.5, 0.0, 0.0)),   // 159
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.5, 0.1, 0.0, 0.15)),   // 160
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.75, 0.15, 0.0, 0.0)),  // 161
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.75, 0.45, 0.0, 0.0)),  // 162
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.75, 0.5, 0.0, 0.0))    // 163
};

// Encode vector to "rgba" uint.
uint encode_rgba_u32(uint r, uint g, uint b, uint a) {
  uint col = 0;
  col = (r << 24) | (g << 16) | (b  << 8) | a;
  return col;
}

// Updates counter until MAX_NUM_CHARS is reached.
// Returns the counter value before incrementation. 
uint update_counter() {
    uint local_index = local_id_to_x();
    uint counter_now = char_arrays[local_index].counter;
    char_arrays[local_index].counter = min(counter_now + 1, MAX_NUM_CHARS-1);
    return counter_now;
}

void create_point_ball(vec3 pos, uint r, uint g, uint b, float dist) {
    
    uint index = atomicAdd(counter[0], 7);
    //++uint index = atomicAdd(counter[0], 1);
    output_points[index] = OutputVertex(pos, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+1] = OutputVertex(pos + vec3(dist , 0.0, 0.0), encode_rgba_u32(r, g, b, 1)); 
    output_points[index+2] = OutputVertex(pos + vec3(-dist , 0.0, 0.0), encode_rgba_u32(r, g, b, 1)); 
    output_points[index+3] = OutputVertex(pos + vec3(0.0 , dist , 0.0), encode_rgba_u32(r, g, b, 1)); 
    output_points[index+4] = OutputVertex(pos + vec3(0.0 , -dist, 0.0), encode_rgba_u32(r, g, b, 1)); 
    output_points[index+5] = OutputVertex(pos + vec3(0.0 , dist , dist ), encode_rgba_u32(r, g, b, 1)); 
    output_points[index+6] = OutputVertex(pos + vec3(0.0 , -dist, -dist), encode_rgba_u32(r, g, b, 1)); 
}

void create_aabb_triangles(AABB aabb, uint r, uint g, uint b) {

    uint aabb_index = atomicAdd(counter[1], 24);

    const vec3 delta = aabb.max.xyz - aabb.min.xyz;
    const vec3 p0 = aabb.min.xyz;
    const vec3 p1 = aabb.min.xyz + vec3(delta.x , 0.0     , 0.0);
    const vec3 p2 = aabb.min.xyz + vec3(delta.x , delta.y , 0.0);
    const vec3 p3 = aabb.min.xyz + vec3(0.0     , delta.y , 0.0);
    const vec3 p4 = aabb.min.xyz + vec3(0.0     , 0.0     , delta.z);
    const vec3 p5 = aabb.min.xyz + vec3(delta.x , 0.0     , delta.z);
    const vec3 p6 = aabb.min.xyz + vec3(delta.x , delta.y , delta.z);
    const vec3 p7 = aabb.min.xyz + vec3(0.0     , delta.y , delta.z);

    OutputVertex p0_out = OutputVertex( p0, encode_rgba_u32(r, g, b, 0));
    OutputVertex p1_out = OutputVertex( p1, encode_rgba_u32(r, g, b, 0));
    OutputVertex p2_out = OutputVertex( p2, encode_rgba_u32(r, g, b, 0));
    OutputVertex p3_out = OutputVertex( p3, encode_rgba_u32(r, g, b, 0));
    OutputVertex p4_out = OutputVertex( p4, encode_rgba_u32(r, g, b, 0));
    OutputVertex p5_out = OutputVertex( p5, encode_rgba_u32(r, g, b, 0));
    OutputVertex p6_out = OutputVertex( p6, encode_rgba_u32(r, g, b, 0));
    OutputVertex p7_out = OutputVertex( p7, encode_rgba_u32(r, g, b, 0));
}


// TODO rename to triangles.
void create_output_points(AABB aabb, uint r, uint g, uint b) {

    uint aabb_index = atomicAdd(counter[1], 36);

    const vec3 delta = aabb.max.xyz - aabb.min.xyz;
    const vec3 p0 = aabb.min.xyz;
    const vec3 p1 = aabb.min.xyz + vec3(delta.x , 0.0     , 0.0);
    const vec3 p2 = aabb.min.xyz + vec3(delta.x , delta.y , 0.0);
    const vec3 p3 = aabb.min.xyz + vec3(0.0     , delta.y , 0.0);
    const vec3 p4 = aabb.min.xyz + vec3(0.0     , 0.0     , delta.z);
    const vec3 p5 = aabb.min.xyz + vec3(delta.x , 0.0     , delta.z);
    const vec3 p6 = aabb.min.xyz + vec3(delta.x , delta.y , delta.z);
    const vec3 p7 = aabb.min.xyz + vec3(0.0     , delta.y , delta.z);

    // FRONT.

    const float lf_factor = 0.3;
    const uint lfr = uint(r*lf_factor);
    const uint lfg = uint(g*lf_factor);
    const uint lfb = uint(b*lf_factor);

    output_points[aabb_index]   = OutputVertex(p6, encode_rgba_u32(lfr, lfg, lfb, 1)); 
    output_points[aabb_index+1] = OutputVertex(p7, encode_rgba_u32(lfr, lfg, lfb, 1)); 
    output_points[aabb_index+2] = OutputVertex(p4, encode_rgba_u32(lfr, lfg, lfb, 1)); 

    output_points[aabb_index+3] = OutputVertex(p4, encode_rgba_u32(lfr, lfg, lfb, 1)); 
    output_points[aabb_index+4] = OutputVertex(p5, encode_rgba_u32(lfr, lfg, lfb, 1)); 
    output_points[aabb_index+5] = OutputVertex(p6, encode_rgba_u32(lfr, lfg, lfb, 1)); 

    // RIGHT.

    const float lr_factor = 0.6;
    const uint lrr = uint(r*lr_factor);
    const uint lrg = uint(g*lr_factor);
    const uint lrb = uint(b*lr_factor);

    output_points[aabb_index+6] = OutputVertex(p5, encode_rgba_u32(lrr, lrg, lrb, 1)); 
    output_points[aabb_index+7] = OutputVertex(p1, encode_rgba_u32(lrr, lrg, lrb, 1)); 
    output_points[aabb_index+8] = OutputVertex(p2, encode_rgba_u32(lrr, lrg, lrb, 1)); 

    output_points[aabb_index+9]  = OutputVertex(p2, encode_rgba_u32(lrr, lrg, lrb, 1)); 
    output_points[aabb_index+10] = OutputVertex(p6, encode_rgba_u32(lrr, lrg, lrb, 1)); 
    output_points[aabb_index+11] = OutputVertex(p5, encode_rgba_u32(lrr, lrg, lrb, 1)); 

    // BACK.

    output_points[aabb_index+12] = OutputVertex(p2, encode_rgba_u32(r, g, b, 1)); 
    output_points[aabb_index+13] = OutputVertex(p1, encode_rgba_u32(r, g, b, 1)); 
    output_points[aabb_index+14] = OutputVertex(p0, encode_rgba_u32(r, g, b, 1)); 

    output_points[aabb_index+15] = OutputVertex(p3, encode_rgba_u32(r, g, b, 1)); 
    output_points[aabb_index+16] = OutputVertex(p2, encode_rgba_u32(r, g, b, 1)); 
    output_points[aabb_index+17] = OutputVertex(p0, encode_rgba_u32(r, g, b, 1)); 

    // LEFT.

    const float ll_factor = 0.6;
    const uint llr = uint(r*ll_factor);
    const uint llg = uint(g*ll_factor);
    const uint llb = uint(b*ll_factor);

    output_points[aabb_index+18] = OutputVertex(p7, encode_rgba_u32(llr, llg, llb, 1)); 
    output_points[aabb_index+19] = OutputVertex(p3, encode_rgba_u32(llr, llg, llb, 1)); 
    output_points[aabb_index+20] = OutputVertex(p0, encode_rgba_u32(llr, llg, llb, 1)); 

    output_points[aabb_index+21] = OutputVertex(p0, encode_rgba_u32(llr, llg, llb, 1)); 
    output_points[aabb_index+22] = OutputVertex(p4, encode_rgba_u32(llr, llg, llb, 1)); 
    output_points[aabb_index+23] = OutputVertex(p7, encode_rgba_u32(llr, llg, llb, 1)); 

    // TOP.

    const float lt_factor = 0.8;
    const uint ltr = uint(r*lt_factor);
    const uint ltg = uint(g*lt_factor);
    const uint ltb = uint(b*lt_factor);

    output_points[aabb_index+24] = OutputVertex(p7, encode_rgba_u32(ltr, ltg, ltb, 1)); 
    output_points[aabb_index+25] = OutputVertex(p6, encode_rgba_u32(ltr, ltg, ltb, 1)); 
    output_points[aabb_index+26] = OutputVertex(p2, encode_rgba_u32(ltr, ltg, ltb, 1)); 

    output_points[aabb_index+27] = OutputVertex(p2, encode_rgba_u32(ltr, ltg, ltb, 1)); 
    output_points[aabb_index+28] = OutputVertex(p3, encode_rgba_u32(ltr, ltg, ltb, 1)); 
    output_points[aabb_index+29] = OutputVertex(p7, encode_rgba_u32(ltr, ltg, ltb, 1)); 

    // BOTTOM.

    const float lb_factor = 0.15;
    const uint lbr = uint(r*lb_factor);
    const uint lbg = uint(g*lb_factor);
    const uint lbb = uint(b*lb_factor);

    output_points[aabb_index+30] = OutputVertex(p1, encode_rgba_u32(lbr, lbg, lbb, 1)); 
    output_points[aabb_index+31] = OutputVertex(p5, encode_rgba_u32(lbr, lbg, lbb, 1)); 
    output_points[aabb_index+32] = OutputVertex(p4, encode_rgba_u32(lbr, lbg, lbb, 1)); 

    output_points[aabb_index+33] = OutputVertex(p4, encode_rgba_u32(lbr, lbg, lbb, 1)); 
    output_points[aabb_index+34] = OutputVertex(p0, encode_rgba_u32(lbr, lbg, lbb, 1)); 
    output_points[aabb_index+35] = OutputVertex(p1, encode_rgba_u32(lbr, lbg, lbb, 1)); 
}

void create_aabb_triangles_r(AABB aabb, uint r, uint g, uint b, float t) {
    AABB back_bottom = AABB(aabb.min, vec4(aabb.max.x, aabb.min.y + t, aabb.min.z + t, 1.0));
    AABB right_bottom = AABB(aabb.min, vec4(aabb.min.x + t, aabb.min.y + t, aabb.max.z, 1.0));
    AABB left_bottom = AABB(vec4(aabb.max.x - t, aabb.min.y, aabb.min.z, 1.0),
                            vec4(aabb.max.x, aabb.min.y + t, aabb.max.z, 1.0));
    AABB front_bottom = AABB(vec4(aabb.min.x, aabb.min.y, aabb.max.z - t, 1.0),
                             vec4(aabb.max.x, aabb.min.y + t, aabb.max.z, 1.0));

    AABB back_top = AABB(vec4(aabb.min.x, aabb.max.y - t, aabb.min.z, 1.0),  
                         vec4(aabb.max.x, aabb.max.y,     aabb.min.z + t, 1.0));
    AABB left_top = AABB(vec4(aabb.min.x,     aabb.max.y - t, aabb.min.z, 1.0),  
                          vec4(aabb.min.x + t, aabb.max.y,     aabb.max.z, 1.0));
    AABB right_top = AABB(vec4(aabb.max.x - t, aabb.max.y - t, aabb.min.z, 1.0),  
                          vec4(aabb.max.x,     aabb.max.y,     aabb.max.z, 1.0));
    AABB front_top = AABB(vec4(aabb.min.x,     aabb.max.y - t, aabb.max.z - t, 1.0),  
                          vec4(aabb.max.x,     aabb.max.y,     aabb.max.z, 1.0));
    AABB back_left_ud = AABB(vec4(aabb.min.x,     aabb.min.y, aabb.min.z, 1.0),  
                             vec4(aabb.min.x + t, aabb.max.y, aabb.min.z + t, 1.0));
    AABB back_right_ud = AABB(vec4(aabb.max.x - t, aabb.min.y, aabb.min.z, 1.0),  
                              vec4(aabb.max.x    , aabb.max.y, aabb.min.z + t, 1.0));
    AABB front_right_ud = AABB(vec4(aabb.min.x,    aabb.min.y, aabb.max.z - t, 1.0),  
                              vec4(aabb.min.x + t, aabb.max.y, aabb.max.z, 1.0));
    AABB front_left_ud = AABB(vec4(aabb.max.x - t, aabb.min.y, aabb.max.z - t, 1.0),  
                              vec4(aabb.max.x    , aabb.max.y, aabb.max.z, 1.0));
    create_output_points(back_bottom, r, g, b); 
    create_output_points(right_bottom, r, g, b); 
    create_output_points(left_bottom, r, g, b); 
    create_output_points(front_bottom, r, g, b); 
    create_output_points(back_top, r, g, b); 
    create_output_points(left_top, r, g, b); 
    create_output_points(right_top, r, g, b); 
    create_output_points(front_top, r, g, b); 
    create_output_points(back_left_ud, r, g, b); 
    create_output_points(back_right_ud, r, g, b); 
    create_output_points(front_right_ud, r, g, b); 
    create_output_points(front_left_ud, r, g, b); 
}


void bezier_4c(uint n, vec4 c0, vec4 c1, vec4 c2, vec4 c3, uint r, uint g, uint b) {

    if (n < 4) return;

    uint index = atomicAdd(counter[0], n);

    for (int i=0 ; i<n ; i++) {
        const float t = float(i)  / (float(n)-1.0);
        const float t2 = t * t;
        const float t3 = t2 * t;
        const float mt = 1.0 - t;
        const float mt2 = mt * mt;
        const float mt3 = mt2 * mt;
        const vec3 result = c0.xyz * mt3 + c1.xyz * 3.0 * mt2*t + c2.xyz * 3.0 * mt*t2 + c3.xyz * t3;
        const float dist = min(max(1.0, distance(camera_pos.xyz, result)), 255);
        output_points[index] = OutputVertex(
            result,
            encode_rgba_u32(
                r,
                g,
                b,
                uint(dist)));
        index++;
    }
}

void create_array(float array_width, vec3 base_pos, vec3 dest_pos, uint r, uint g, uint b) {

    vec3 array_direction = normalize(dest_pos - base_pos);
    vec3 camera_direction = normalize(camera_pos.xyz - base_pos);

    // Array length.
    float array_length = distance(dest_pos, base_pos);
    float array_base_length = array_length - array_width;

    vec3 side_direction = cross(camera_direction, array_direction);   

    uint index = atomicAdd(counter[1], 21);

    const vec3 p0 = base_pos;
    const vec3 p1 = base_pos + side_direction * array_width;
    const vec3 p2 = base_pos - side_direction * array_width;
    const vec3 p3 = p1 + array_direction * array_base_length;
    const vec3 p4 = p2 + array_direction * array_base_length;
    const vec3 p5 = base_pos + array_direction * array_base_length;
    const vec3 p6 = dest_pos;
    const vec3 p7 = p3 + side_direction * array_width * 2.0;
    const vec3 p8 = p4 - side_direction * array_width * 2.0;

    output_points[index]   = OutputVertex(p1, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+1] = OutputVertex(p0, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+2] = OutputVertex(p3, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+3] = OutputVertex(p0, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+4] = OutputVertex(p5, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+5] = OutputVertex(p3, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+6] = OutputVertex(p0, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+7] = OutputVertex(p2, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+8] = OutputVertex(p4, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+9] = OutputVertex(p4, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+10] = OutputVertex(p5, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+11] = OutputVertex(p0, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+12] = OutputVertex(p3, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+13] = OutputVertex(p4, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+14] = OutputVertex(p6, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+15] = OutputVertex(p3, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+16] = OutputVertex(p6, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+17] = OutputVertex(p7, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+18] = OutputVertex(p4, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+19] = OutputVertex(p8, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+20] = OutputVertex(p6, encode_rgba_u32(r, g, b, 1)); 
}

// uint get_remainder(uint num, uint divisor) {
//     return (num - divisor * (num / divisor));
// }

void log_number(uint n, bool ignore_first) {
       // 4294967295 
       // 1000000000
    uint local_index = local_id_to_x();

    bool found = false;
    bool ignore = ignore_first;
    uint temp_n = n;

    if (n == 0) {
        char_arrays[local_index].chars[update_counter()] = 0;
        return;
    }

    for (int i=9 ; i>=0 ; i--) {
        uint remainder = temp_n / joo[i];  
        temp_n -= remainder * joo[i];
        if (remainder != 0) {
            found = true;	    
        }
        if (found == true) {
            if (ignore == true) { ignore = false; continue; }
            char_arrays[local_index].chars[update_counter()] = remainder; 
        }
    }
}

void create_char(uint char_index, uint num_points, vec4 offset, uint r, uint g, uint b) {

    uint index = bez_indices[char_index];

    uint indices[4] = {
        index & 0xff,
        (index & 0xff00) >> 8,
        (index & 0xff0000) >> 16,
        (index & 0xff000000) >> 24,
    };

    for (uint i=0 ; i<4 ; i++) {
        uint bez_index = indices[i];
        if (bez_index == 255) break;
        vec4 bi = bez_table[bez_index];
        uint count = uint(max(1.0, num_points * bi.w));
        bezier_4c(
            count,
            FONT_SIZE * bez_table[bez_index + 0] + offset,
            FONT_SIZE * bez_table[bez_index + 1] + offset,
            FONT_SIZE * bez_table[bez_index + 2] + offset,
            FONT_SIZE * bez_table[bez_index + 3] + offset,
            r,
            g,
            b
        );
    }
}

void log_float(double f, uint max_decimals) {

    uint local_index = local_id_to_x();
    //uint counter_now = counter;

    // The sign of given float.
    bool is_negative = f < 0.0;

    // Add minus.
    if (is_negative) {
        char_arrays[local_index].chars[update_counter()] = 10;
        //char_arrays[local_index].counter++;
    }

    double f_positive = abs(f);

    // The integer part.
    float integer_temp; 

    // The fractional component.
    double _f_part = modf(float(f_positive), integer_temp);

    double f_part = fract(f_positive);

    // Multiply fractional part so it becomes uint.
    uint fract_part = uint((f_part+1.0)*joo[max_decimals]); //pow(10.0, max_decimals));

    // Cast integer part to uint.
    uint integer_part = uint(abs(integer_temp));

    // Parse the integer part.
    log_number(integer_part, false);

    // Add dot.
    char_arrays[local_index].chars[update_counter()] = 13;

    // Parse the frag part.
    log_number(fract_part, true);
}

void log_uvec3(uvec3 v) {

    uint local_index = local_id_to_x();

    // Add left paren.
    char_arrays[local_index].chars[update_counter()] = 11;

    log_number(v.x, false);

    // Add space x 2.
    char_arrays[local_index].chars[update_counter()] = 16;
    char_arrays[local_index].chars[update_counter()] = 16;

    log_number(v.y, false);

    // Add space x 2.
    char_arrays[local_index].chars[update_counter()] = 16;
    char_arrays[local_index].chars[update_counter()] = 16;

    log_number(v.z, false);
    
    // Add right paren.
    char_arrays[local_index].chars[update_counter()] = 12;

}

void log_vec3(vec3 v, uint max_decimals) {
    
    uint local_index = local_id_to_x();

    // Add left paren.
    char_arrays[local_index].chars[update_counter()] = 11;

    // log_float(double(v.x), 7);
    log_float(double(v.x), max_decimals);

    // Add space x 2.
    char_arrays[local_index].chars[update_counter()] = 16;
    char_arrays[local_index].chars[update_counter()] = 16;

    //log_float(double(v.y), 7);
    log_float(double(v.y), max_decimals);

    // Add space x 2.
    char_arrays[local_index].chars[update_counter()] = 16;
    char_arrays[local_index].chars[update_counter()] = 16;

    //log_float(double(v.z), 7);
    log_float(double(v.z), max_decimals);
    
    // Add right paren.
    char_arrays[local_index].chars[update_counter()] = 12;
}

AABB create_char_sequency_points(uint r, uint g, uint b) {

    uint local_index = local_id_to_x();
    vec3 base_vector = char_arrays[local_index].position;
    const float dist = distance(base_vector, camera_pos.xyz);
    uint average_points_per_char = max(4, uint(min(MAX_NUM_OF_POINTS, MAX_NUM_OF_POINTS / pow(dist, 2.0)))); 
    vec4 local_offset = vec4(base_vector, 0.0);
    uint number_of_lines = 0;
    uint max_text_width = 0;
    uint text_width = 0;
      
    for (uint i=0; i<char_arrays[local_index].counter; i++) {
        uint numb = char_arrays[local_index].chars[i];

        // end of line.
        if (numb == 17) {
            number_of_lines++;
            local_offset = vec4(base_vector, 0.0) + vec4(0.0, (-FONT_OFFSET_Y) * float(number_of_lines) * FONT_SIZE, 0.0, 0.0);
            if (text_width > max_text_width) {
                max_text_width = text_width;
                text_width = 0;
            }
        }
        else {
            create_char(numb, average_points_per_char, local_offset, r, g, b);
            local_offset = local_offset + vec4(FONT_SIZE * 0.7, 0.0, 0.0, 0.0);
            text_width++;
        }
    }

    AABB aabb = AABB(
      vec4(base_vector, 0.0) + vec4(-0.5 * FONT_SIZE, number_of_lines * (-FONT_OFFSET_Y - 0.1) * FONT_SIZE, -0.05, 0.0),
      vec4(base_vector, 0.0) + FONT_SIZE * vec4(max_text_width * 0.8, FONT_OFFSET_Y, 0.0, 0.0) + vec4(0.0,0.0,-0.001,0.0)
    );
    return aabb;
}

void add_end_of_line() {
    uint local_index = local_id_to_x();
    char_arrays[local_index].chars[char_arrays[local_index].counter] = 17;
    char_arrays[local_index].counter++;
}

void initialize_char_array(vec3 position) {

    uint local_index = local_id_to_x();

    char_arrays[local_index].counter = 0;
    char_arrays[local_index].position = position;
}


// Add the neighbor far points to the band. 
void update_neighbors(uvec3 grid_coord) {
    
    // Access all 6 directions. If a far point is found, mark it as band point.
}

// 
uint block_coord_to_block_index(uvec3 coord) {
  uint block_index = coord.x +
                     coord.y * 4 +
                     coord.z * 16;
  return block_index;
}

// For given block index,
uvec3 work_x_index_to_uvec3(uint work_index) {
  //uint work_index = gl_WorkGroupID.x;
  uint index = work_index;
  uint wh = group_dimension.x * group_dimension.y;
  uint z = index / wh;
  index -= z * wh;
  uint y = index / group_dimension.x;
  index -= y * group_dimension.x;
  uint x = index;
  return uvec3(x, y, z);
}

// Calculate uvec3 from given index and dimensions.
uvec3 index_to_uvec3(uint the_index, uint dim_x, uint dim_y) {
  uint index = the_index;
  uint wh = dim_x * dim_y;
  uint z = index / wh;
  index -= z * wh;
  uint y = index / dim_x;
  index -= y * dim_x;
  uint x = index;
  return uvec3(x, y, z);
}

void push_chars(uint r, uint g, uint b) {

  uint local_index = local_id_to_x();
  vec3 original_coord = char_arrays[local_index].position;

  AABB aabb = create_char_sequency_points(255, 125, 125);
  AABB traslated = AABB(vec4(original_coord, 1.0), vec4(original_coord + vec3(1.0, 1.0, 1.0), 1.0));
  create_output_points(aabb,
                    r,
                    g,
                    b
                    );
  //initialize_char_array(new_base_coord);
}

// Add a chunk of block data to a temporary 'shared_perix_sum' buffer.
// Copies FMM_Block to shared_prefix_sum {0,1}. Add padding 0 if necessery.
void copy_block_to_temp(uint chunck_id, uint number_of_items) {

    // Create the local indices.
    const uint ai = local_id_to_x(); 
    const uint bi = ai + THREAD_COUNT;

    // Create the bank conflict free local indices.
    const uint ai_bcf = ai + (ai >> 4); 
    const uint bi_bcf = bi + (bi >> 4);

    // Create the global indices to access the global memory.
    const uint global_ai = ai + chunck_id * (THREAD_COUNT * 2);
    const uint global_bi = bi + chunck_id * (THREAD_COUNT * 2);

    // Create {0:1} array from the global fmm_block array.
    // 0 :: no band cells.
    // 1 :: band cells > 0.

    FMM_Block a = fmm_block[global_ai];
    FMM_Block b = fmm_block[global_bi];

    shared_prefix_sum[ai_bcf] = uint((ai < number_of_items) && (a.band_points_count > 0));
    shared_prefix_sum[bi_bcf] = uint((bi < number_of_items) && (b.band_points_count > 0));

    // const vec3 this_coord  = vec3((ai + chunck_id*(THREAD_COUNT * 2)) * DEBUG_OFFSET, 0.0, 0.0);
    // const vec3 this_coord2 = vec3((bi + chunck_id*(THREAD_COUNT * 2)) * DEBUG_OFFSET, 0.0, 0.0);
    // const vec3 this_coord  = vec3(ai * DEBUG_OFFSET, 0.0, 0.0);
    // const vec3 this_coord2 = vec3(bi * DEBUG_OFFSET, 0.0, 0.0);

    // initialize_char_array(this_coord + vec3(0.0, DEBUG_OFFSET * (chunck_id+4), 0.0));
    // log_number(ai + chunck_id*(THREAD_COUNT * 2), false);
    // add_end_of_line();
    // log_number(shared_prefix_sum[ai_bcf], false);
    // add_end_of_line();
    // push_chars(255 - local_id_to_x() * 4, local_id_to_x() * 4, 20);

    // initialize_char_array(this_coord2 + vec3(0.0, DEBUG_OFFSET * (chunck_id+4), 0.0));

    // log_number(bi + chunck_id*(THREAD_COUNT * 2), false);
    // add_end_of_line();
    // log_number(shared_prefix_sum[bi_bcf], false);
    // add_end_of_line();
    // push_chars(255 - local_id_to_x() * 4, local_id_to_x() * 4, 20);
}

void copy_prefix_sum_to_temp(uint chunck_id) {

    // Create the local indices.
    const uint ai = local_id_to_x(); 
    const uint bi = ai + THREAD_COUNT;

    // Create the bank conflict free local indices.
    const uint ai_bcf = ai + (ai >> 4); 
    const uint bi_bcf = bi + (bi >> 4);

    // Create the global indices to access the global memory.
    const uint global_ai = ai + chunck_id * (THREAD_COUNT * 2);
    const uint global_bi = bi + chunck_id * (THREAD_COUNT * 2);

    temp_prefix_sum[global_ai] = shared_prefix_sum[ai_bcf];
    temp_prefix_sum[global_bi] = shared_prefix_sum[bi_bcf];
}

// Perform prefix sum. Return the exclusive part of the prefix sum.
// NOTE: only the thread 0 returns the actual exclusive part.
uint local_prefix_sum() {

    // Create the local indices.
    const uint ai = local_id_to_x(); 
    const uint bi = ai + THREAD_COUNT;

    // Create the bank conflict free local indices.
    const uint ai_bcf = ai + (ai >> 4); 
    const uint bi_bcf = bi + (bi >> 4);

    uint exclusive_part = 0;

    // Up sweep.

    const int n = THREAD_COUNT*2;
    int offset = 1;
    for (int d = n>>1 ; d > 0; d >>= 1) {
      barrier();
      //if (local_id_x < d) {
      if (ai < d) {

          int ai_temp = offset*(int(ai*2)+1)-1; // 0, 2, 4, 6
          int bi_temp = offset*(int(ai*2)+2)-1; // 1, 3, 5, 7

          ai_temp += (ai_temp >> 4);
          bi_temp += (bi_temp >> 4);

          shared_prefix_sum[bi_temp] += shared_prefix_sum[ai_temp];
      }
      offset *= 2;
    }
    barrier();
      
    // Clear the last item. 
    if (ai == 0) {

        // Global last index.
        uint last_index = (THREAD_COUNT * 2) -1 + ((THREAD_COUNT * 2 - 1) >> 4);

        // Copy the last prefix sum to the shared_aux. 
        exclusive_part = shared_prefix_sum[last_index];

        // Add zero to the last index.
        shared_prefix_sum[last_index] = 0;
    }
    
    // Down sweep.
    for (int d = 1; d < n ; d *=2) {
      offset >>= 1;
      barrier();
      if (ai < d) {
          int ai_temp = offset*(int(ai*2)+1)-1;
          int bi_temp = offset*(int(ai*2)+2)-1;
          ai_temp += (ai_temp >> 4);
          bi_temp += (bi_temp >> 4);
          uint t = shared_prefix_sum[ai_temp];

          shared_prefix_sum[ai_temp] = shared_prefix_sum[bi_temp];
          shared_prefix_sum[bi_temp] += t;
      }
  }
  return exclusive_part;
}

// Perform prefix sum for shared_aux. Return the exclusive part of the prefix sum.
uint local_prefix_sum_aux() {

    // Create the local indices.
    const uint ai = local_id_to_x(); 
    const uint bi = ai + THREAD_COUNT;

    // Create the bank conflict free local indices.
    const uint ai_bcf = ai + (ai >> 4); 
    const uint bi_bcf = bi + (bi >> 4);

    uint exclusive_part = 0;

    // Up sweep.

    const int n = THREAD_COUNT*2;
    int offset = 1;
    for (int d = n>>1 ; d > 0; d >>= 1) {
      barrier();
      if (ai < d) {

          int ai_temp = offset*(int(ai*2)+1)-1; // 0, 2, 4, 6
          int bi_temp = offset*(int(ai*2)+2)-1; // 1, 3, 5, 7

          ai_temp += (ai_temp >> 4);
          bi_temp += (bi_temp >> 4);

          shared_aux[bi_temp] += shared_aux[ai_temp];
      }
      offset *= 2;
    }
    barrier();
      
    // Clear the last item. 
    if (ai == 0) {

        // Global last index.
        uint last_index = (THREAD_COUNT * 2) -1 + ((THREAD_COUNT * 2 - 1) >> 4);

        // Copy the last prefix sum to the shared_aux. 
        stream_compaction_count = shared_aux[last_index];

        // Add zero to the last index.
        shared_aux[last_index] = 0;
    }
    
    // Down sweep.
    for (int d = 1; d < n ; d *=2) {
      offset >>= 1;
      barrier();
      if (ai < d) {
          int ai_temp = offset*(int(ai*2)+1)-1;
          int bi_temp = offset*(int(ai*2)+2)-1;
          ai_temp += (ai_temp >> 4);
          bi_temp += (bi_temp >> 4);
          uint t = shared_aux[ai_temp];

          shared_aux[ai_temp] = shared_aux[bi_temp];
          shared_aux[bi_temp] += t;
      }
  }
  return exclusive_part;
}

// Stream compation.
void solve_active_fmm_block(uint number_of_scan_blocks) {

    uint local_id_x = local_id_to_x(); 

    for (int j=0 ; j < number_of_scan_blocks ; j++) {
    
      uint ai = local_id_x + j * THREAD_COUNT * 2;
      uint bi = (local_id_x + THREAD_COUNT) + j * THREAD_COUNT * 2;
    
      uint ai_active = ai + ACTIVE_FMM_BLOCKS_OFFSET;
      uint bi_active = bi + ACTIVE_FMM_BLOCKS_OFFSET;
    
      FMM_Block a = fmm_block[ai];
      FMM_Block b = fmm_block[bi];
    
      bool add_a = a.band_points_count > 0;
      bool add_b = b.band_points_count > 0;
    
      if (add_a) {
          uint index_to_add = temp_prefix_sum[ai];
          fmm_block[index_to_add + ACTIVE_FMM_BLOCKS_OFFSET] = a;
      }
      if (add_b) {
          uint index_to_add = temp_prefix_sum[bi];
          fmm_block[index_to_add + ACTIVE_FMM_BLOCKS_OFFSET] = b;
      }
    }
}

uint global_solver() {

  // This should come from the host program.
  const int number_of_blocks = 512; 

  // Convert 4x4x4 index to uint.
  uint local_id_x = local_id_to_x();

  // Reset the counter for active blocks. 
  if (local_id_x == 0) stream_compaction_count = 0;
  
  // Number of data chunks. There must be at least one iteration.
  // neeeded. TODO: check number_of_blocks == 0. Return immediatelly if it
  // true.
  //const int number_of_scan_blocks = (number_of_blocks - 1) / 128 + 1; const int number_of_scan_blocks = (number_of_blocks - 1) / 128 + 1;
  const int number_of_scan_blocks = (number_of_blocks - 1) / (THREAD_COUNT*2) + 1;

  // Available items count.
  uint items_available = number_of_blocks;

  // The number of items on current chunk.
  uint number_of_taken_items = 0; 

  // Create the local indices.
  const uint ai = local_id_to_x(); 
  const uint bi = ai + THREAD_COUNT;

  // Create the local indices.
  const uint ai_bcf = ai + (ai >> 4); 
  const uint bi_bcf = bi + (bi >> 4);
  
  // Add zeroes to the shared_aux (the conflict free indexes).
  shared_aux[ai_bcf] = 0;
  shared_aux[bi_bcf] = 0;
  shared_prefix_sum[ai_bcf] = 8;
  shared_prefix_sum[bi_bcf] = 3;
  // barrier();

  // FMM_Blocks are converted to boolean array.
  // FMM_Block.band_points_count >  0 :: 1
  // FMM_Block.band_points_count == 0 :: 0
  // Perfom prefix sum on boolean array.
  for (int j=0 ; j < number_of_scan_blocks ; j++) {

      // Determine the count of items in this iteration.
      number_of_taken_items = min(THREAD_COUNT * 2, items_available);

      // Decrease the number of available items.
      items_available -= number_of_taken_items;

      // Copy data from global FMM_Block array to
      // shared_prefix_sum. [{0,1}]
      copy_block_to_temp(j, number_of_taken_items);

      // Perform the prefix_sum.
      uint exclusive_part = local_prefix_sum();

      // Add the exclusive part to the shared aux.
      if (local_id_x == 0) shared_aux[j + (j >> 4)] = exclusive_part; 

      // Copy local prefix sum data to 'temp_prefix_sum' buffer.
      copy_prefix_sum_to_temp(j);
  }

  // Perform the prefix_sum for shared_aux.
  uint aux_exclusive_part = local_prefix_sum_aux();

  // Add the shared_aux to the final result.
  for (int j=0 ; j < number_of_scan_blocks ; j++) {
    uint value_to_add = shared_aux[j + (j >> 4)]; 

    // Create the global indices to access the global memory.
    const uint global_ai = ai + j * (THREAD_COUNT * 2);
    const uint global_bi = bi + j * (THREAD_COUNT * 2);

    temp_prefix_sum[global_ai] += value_to_add; 
    temp_prefix_sum[global_bi] += value_to_add; 
  }

  // Finally. Update the number of active FMM_Blocks.

  solve_active_fmm_block(number_of_scan_blocks);

  return 777;
}


void copy_offset_to_shared(uint thread_id) {
    shared_offset_table[thread_id] = offset_hash_table[thread_id];
}

void copy_vec_to_offset_to_shared(uint thread_id) {
    shared_vec_to_offset[thread_id] = vec_to_offset_table[thread_id];
}

// Calculate from local coordinate to local shared index (map from local indes
// to local index hash map value.
// Prerequisites: shared_vec_to_offset must be initialized before using this function.
uint get_transformed_index(ivec3 position) {
    const ivec3 transformed_position = position + ivec3(1,1,1);
    const uint position_index = transformed_position.x + transformed_position.y * 6 + transformed_position.z * 36;
    return shared_vec_to_offset[position_index];
}

// Loads offset hash table to shared memory.
void load_offset_hash_table() {

  const uint number_of_threads = LOCAL_X_DIM * LOCAL_Y_DIM;  
  const uint number_of_offset_blocks = (fmm_attributes.offset_hash_table_size - 1) / number_of_threads + 1;

  for (int j=0 ; j < number_of_offset_blocks ; j++) {
      const uint thread_id = j * number_of_threads + gl_LocalInvocationIndex;
      if (thread_id >= fmm_attributes.offset_hash_table_size) break;
      copy_offset_to_shared(thread_id);
  }
}

// Loads vec to offset hash table to shared memory.
void load_vec_to_offset() {

  const uint number_of_threads = LOCAL_X_DIM * LOCAL_Y_DIM;  
  const uint number_of_vec_to_offset_blocks = (fmm_attributes.vec_to_offset_table_size - 1) / number_of_threads + 1;

  for (int j=0 ; j < number_of_vec_to_offset_blocks ; j++) {

      const uint thread_id = j * number_of_threads + gl_LocalInvocationIndex;
      if (thread_id >= fmm_attributes.vec_to_offset_table_size) break;
      copy_vec_to_offset_to_shared(thread_id);
  }
}

// Load fmm node data to shared memory. Does not get data from outside
// global computational context.
void load_fmm_data(uint base_index, ivec3 global_base_coord, bool center_data_only) {

    const uint number_of_blocks =
        center_data_only ? 1 : (fmm_attributes.offset_hash_table_size - 1) / 64 + 1;

    for (int x=0 ; x < number_of_blocks ; x++) {

        const uint thread_id = x * 64 + gl_LocalInvocationID.x;

        if (thread_id < fmm_attributes.offset_hash_table_size) {

            const ivec4 pos_and_offset = shared_offset_table[thread_id];
            ivec3 global_index = pos_and_offset.xyz + global_base_coord;

            bool outside = global_index.x < 0 ||
                           global_index.y < 0 ||
                           global_index.z < 0 ||
                           global_index.x >= fmm_attributes.global_dimensions.x*4 ||
                           global_index.y >= fmm_attributes.global_dimensions.y*4 ||
                           global_index.z >= fmm_attributes.global_dimensions.z*4;

            //shared_fmm_nodes[thread_id + gl_LocalInvocationID.y * 160] = 
            shared_fmm_nodes[thread_id + gl_LocalInvocationID.y * 160] = 
                outside ? FMM_Node(0.0, 5) : fmm_nodes[pos_and_offset.w + int(base_index)];

            //++ vec3 this_coord = vec3(global_index);
            //++ initialize_char_array(this_coord);

            //++ uvec3 final_color = uvec3(255, 100, 100);

            //++ log_vec3(this_coord, 1);
            //++ //log_number(thread_id, false);
            //++ add_end_of_line();
            //++ AABB aabb = create_char_sequency_points(255, 125, 125);
            //++ AABB traslated = AABB(vec4(this_coord, 1.0), vec4(this_coord + vec3(1.0, 1.0, 1.0), 1.0));
            //++ create_output_points(aabb, final_color.x, final_color.y, final_color.z);

            // if (outside) {
            //     create_point_ball(global_index, 30, 255, 0, 0.01);
            //     // initialize_char_array(global_index);
            //     // log_uvec3(global_index);
            //     // add_end_of_line();
            //     // push_chars(255,255,20);
            // }

            // if (pos_and_offset.w + int(base_index) < 0) {
            //     shared_fmm_nodes[thread_id + gl_LocalInvocationID.y * 160] =
            //         FMM_Node(0.0, 6);
            // }
        }
    }
}

void save_fmm_data(uint base_index, ivec3 global_base_index, bool center_data_only) {

    const uint number_of_blocks =
        center_data_only ? 1 : (fmm_attributes.offset_hash_table_size - 1) / 64 + 1;

    for (int x=0 ; x < number_of_blocks ; x++) {

        const uint thread_id = x * 64 + gl_LocalInvocationID.x;

        if (thread_id < fmm_attributes.offset_hash_table_size) {

            const ivec4 pos_and_offset = offset_hash_table[thread_id];
            ivec3 global_index = pos_and_offset.xyz + global_base_index;

            bool outside = global_index.x < 0 ||
                           global_index.y < 0 ||
                           global_index.z < 0 ||
                           global_index.x >= fmm_attributes.global_dimensions.x*4 ||
                           global_index.y >= fmm_attributes.global_dimensions.y*4 ||
                           global_index.z >= fmm_attributes.global_dimensions.z*4;
            if (!outside) {
                fmm_nodes[pos_and_offset.w + int(base_index)] = shared_fmm_nodes[thread_id + gl_LocalInvocationID.y * 160]; 
            }
        }
    }
}

// 
//     -x       +x       -y        +y      -z       +z   
//  +--------+--------+--------+--------+--------+--------+
//  |  0     |   1    |   2    |   3    |   4    |   5    | 
//  +--------+--------+--------+--------+--------+--------+
// 
//void get_neighbors(ivec4 pos_and_offset, out FMM_Node[6] neighbors, out uint[6] neighbor_indices) {
void get_neighbors(uint cell_index, uint work_index, out FMM_Node[6] neighbors, out uint[6] neighbor_indices) {

        ivec4 pos_and_offset = shared_offset_table[cell_index];

        uint right = get_transformed_index(pos_and_offset.xyz + ivec3(1,0,0));
        uint left  = get_transformed_index(pos_and_offset.xyz + ivec3(-1,0,0));
        uint up    = get_transformed_index(pos_and_offset.xyz + ivec3(0,1,0));
        uint down  = get_transformed_index(pos_and_offset.xyz + ivec3(0,-1,0));
        uint front = get_transformed_index(pos_and_offset.xyz + ivec3(0,0,1));
        uint back  = get_transformed_index(pos_and_offset.xyz + ivec3(0,0,-1));

        neighbors[0] = shared_fmm_nodes[left + 160 * work_index]; // LEFT
        neighbors[1] = shared_fmm_nodes[right + 160 * work_index]; // RIGHT
        neighbors[2] = shared_fmm_nodes[down + 160 * work_index]; // DOWN
        neighbors[3] = shared_fmm_nodes[up + 160 * work_index]; // UP
        neighbors[4] = shared_fmm_nodes[back + 160 * work_index]; // BACK
        neighbors[5] = shared_fmm_nodes[front + 160 * work_index]; // FRONT

        neighbor_indices[0] = left + 160 * work_index;
        neighbor_indices[1] = right + 160 * work_index;
        neighbor_indices[2] = down + 160 * work_index;
        neighbor_indices[3] = up + 160 * work_index;
        neighbor_indices[4] = back + 160 * work_index;
        neighbor_indices[5] = front + 160 * work_index;
}

float solve_quadratic(uint cell_index) {

        // Band cell to be processed.
        FMM_Node node = shared_fmm_nodes[gl_LocalInvocationIndex];

        // Surrounding neighbors.
        FMM_Node[6] neighbors;
        uint[6] neighbor_indices;

        get_neighbors(gl_LocalInvocationID.x, gl_LocalInvocationID.y, neighbors, neighbor_indices);

        // Best cell values in x-y-z directions. Values are calculated 
        // from known cell neighbors only.

        vec3 phis = vec3(0.0, 0.0, 0.0);

        // Deltas. 
        //let mut hs: [f32; 3] = [0.0, 0.0, 0.0];
        float hs[3] = {0.0, 0.0, 0.0};

        //The grid x-length. ???
        //float h = 1.0;

        // X-DIRECTION

        // x dir.
        hs[0] = neighbors[0].tag == 2 && neighbors[1].tag == 2 ? min(neighbors[0].value, neighbors[1].value) : 0.0;
        hs[0] = neighbors[0].tag == 2 && neighbors[1].tag != 2 ? neighbors[0].value : 0.0;
        hs[0] = neighbors[0].tag != 2 && neighbors[1].tag == 2 ? neighbors[1].value : 0.0;

        // y dir.
        hs[1] = neighbors[2].tag == 2 && neighbors[3].tag == 2 ? min(neighbors[2].value, neighbors[3].value) : 0.0;
        hs[1] = neighbors[2].tag == 2 && neighbors[3].tag != 2 ? neighbors[2].value : 0.0;
        hs[1] = neighbors[2].tag != 2 && neighbors[3].tag == 2 ? neighbors[3].value : 0.0;

        // z dir.
        hs[2] = neighbors[4].tag == 2 && neighbors[5].tag == 2 ? min(neighbors[4].value, neighbors[5].value) : 0.0;
        hs[2] = neighbors[4].tag == 2 && neighbors[5].tag != 2 ? neighbors[4].value : 0.0;
        hs[2] = neighbors[4].tag != 2 && neighbors[5].tag == 2 ? neighbors[5].value : 0.0;

        float a = 0.0;
        float b = 0.0;
        float c = 0.0;

        for (int i=0 ; i<3 ; i++) {
            float oho = pow(hs[i], 2.0);
            a += oho;
            b += oho * phis[i];
            c += oho * pow(phis[i],2.0);
        }

        c -= 1.0; // Speed function 1/(f_i,j,k)^2 

        float final_distance = 777.0;
        float discriminant = pow(b, 2.0) - (4.0*a*c);

        if (discriminant >= 0.0) {
            float t_phi = (-1.0*b + sqrt(discriminant)) / (2.0*a); 
            if (phis[0] < t_phi && phis[1] < t_phi && phis[2] < t_phi) {
                final_distance = t_phi; 
            }
        }

        return final_distance;
}

// update band point values.
void update_band_points() {

}

void add_initial_band_points() {

  uint global_dimension_length = fmm_attributes.global_dimensions.x *
                                 fmm_attributes.global_dimensions.y *
                                 fmm_attributes.global_dimensions.z;

  // Create BAND points to the inital initial interface.

  const uint offset = global_dimension_length/LOCAL_Y_DIM;

  for (int b = 0; b<offset ; b++) {

        uvec3 ijk = index_to_uvec3(b + offset * gl_LocalInvocationID.y,
                                   fmm_attributes.global_dimensions.x,
                                   fmm_attributes.global_dimensions.y);
                                   
        uint i = ijk.x;
        uint j = ijk.y;
        uint k = ijk.z;

        const uint base_index = i * 64 +
                                j * 64 * fmm_attributes.global_dimensions.x +
                                k * 64 * fmm_attributes.global_dimensions.x * fmm_attributes.global_dimensions.y;

        // Load FMM nodes to the shared memory.
        load_fmm_data(base_index, ivec3(i, j, k) * 4, false);
        barrier();

        FMM_Node node = shared_fmm_nodes[gl_LocalInvocationID.x + 160 * gl_LocalInvocationID.y];

        // Create BAND points.
        if (node.tag == 2) {

            FMM_Node[6] neighbors;
            uint[6] neighbor_indices;
            get_neighbors(gl_LocalInvocationID.x, gl_LocalInvocationID.y, neighbors, neighbor_indices);

            shared_fmm_nodes[neighbor_indices[0]].tag =  
                neighbors[0].tag != 2 ? 1 : shared_fmm_nodes[neighbor_indices[0]].tag;

            shared_fmm_nodes[neighbor_indices[1]].tag =  
                neighbors[1].tag != 2 ? 1 : shared_fmm_nodes[neighbor_indices[1]].tag;

            shared_fmm_nodes[neighbor_indices[2]].tag =  
                neighbors[2].tag != 2 ? 1 : shared_fmm_nodes[neighbor_indices[2]].tag;

            shared_fmm_nodes[neighbor_indices[3]].tag =  
                neighbors[3].tag != 2 ? 1 : shared_fmm_nodes[neighbor_indices[3]].tag;

            shared_fmm_nodes[neighbor_indices[4]].tag =  
                neighbors[4].tag != 2 ? 1 : shared_fmm_nodes[neighbor_indices[4]].tag;

            shared_fmm_nodes[neighbor_indices[5]].tag =  
                neighbors[5].tag != 2 ? 1 : shared_fmm_nodes[neighbor_indices[5]].tag;
        }

        barrier();

        // Update both center data and ghost region band points.
        save_fmm_data(base_index, ivec3(i, j, k) * 4, false);

        barrier();

  } // for
}

void render_fmm_nodes() {

  uint all_dimension_length = fmm_attributes.global_dimensions.x *
                              fmm_attributes.global_dimensions.y *
                              fmm_attributes.global_dimensions.z;

  const uint offset = all_dimension_length/LOCAL_Y_DIM;

  for (int b = 0; b<offset ; b++) {

        uvec3 ijk = index_to_uvec3(b + offset * gl_LocalInvocationID.y,
                                   fmm_attributes.global_dimensions.x,
                                   fmm_attributes.global_dimensions.y);

            uint i = ijk.x;
            uint j = ijk.y;
            uint k = ijk.z;

            const uint base_index = i * 64 +
                                    j * 64 * fmm_attributes.global_dimensions.x +
                                    k * 64 * fmm_attributes.global_dimensions.x * fmm_attributes.global_dimensions.y;

            // Load FMM nodes to the shared memory.
            load_fmm_data(base_index, ivec3(i, j, k) * 4, false);
            barrier();

            ivec4 pos_and_offset = shared_offset_table[gl_LocalInvocationID.x];
            ivec3 this_coord_oho = pos_and_offset.xyz + ivec3(i, j, k) * 4;
            vec3 this_coord = vec3(this_coord_oho.x, this_coord_oho.y, this_coord_oho.z) ;
            
            FMM_Node node = shared_fmm_nodes[gl_LocalInvocationID.x + 160 * gl_LocalInvocationID.y];

            if (node.tag == 2) {
                uint factor = 100 + uint(abs(node.value * 150.0));
                uvec3 final_color = node.value < 0.0 ? uvec3(0,0,factor) : uvec3(factor,0,0);
                create_point_ball(this_coord, 0, 255, 0, 0.01);
            }
            if (node.tag == 1) {
                vec3 this_coord = pos_and_offset.xyz + ivec3(i, j, k) * 4;
                create_point_ball(this_coord, 255, 0, 0, 0.01);
            }
            if (node.tag == 5) {
                create_point_ball(this_coord, 255, 255, 255, 0.01);
            }
            // if (node.tag == 6) {
            //     vec3 this_coord = pos_and_offset.xyz + ivec3(i, j, k) * 4;
            //     create_point_ball(this_coord, 0, 0, 255, 0.01);
            // }

        barrier();
    } // for
}

void main() {

  /* LOAD COUNTERS. DEBUGGING. */
  if (local_id_to_x() == 0) {
    counter[0] = atomic_counters[0];
    counter[1] = atomic_counters[1];

    /* RENDER THE GLOBAL AABB. */
    AABB scene_aabb = AABB(vec4(-0.15, -0.15, 0.15, 1.0),
                           vec4(fmm_attributes.global_dimensions.x * 4,
                                fmm_attributes.global_dimensions.y * 4,
                                fmm_attributes.global_dimensions.z * 4,
                                1.0) + vec4(0.15, 0.15, -0.15, 0.0));
    create_aabb_triangles_r(scene_aabb,
                      150,
                      100,
                      100,
                      0.15
    );
  }
  //groupMemoryBarrier();
  barrier();

  // solve_active_fmm_blocks();
  ////global_solver();

  /* LOAD HASH TABLES TO SHARED MEMORY. */

  load_offset_hash_table(); // OK?
  load_vec_to_offset(); // OK?
  //groupMemoryBarrier();
  barrier();

  /* CREATE FIRST BAND FOR INITIAL FMM NODES. */

  add_initial_band_points();
  barrier();

  /* RENDER NODES. DEBUGGING. */

  //render_fmm_nodes();
  ////groupMemoryBarrier();
  //barrier();

  /* UPDATE COUNTERS. DEBUGGING. */
  if (local_id_to_x() == 0) {
    atomic_counters[0] = counter[0];
    atomic_counters[1] = counter[1];
  }
}

// NOTES:TODO
// Create blocks in kernel.

#version 450

#define MAX_NUM_CHARS 32 

#define LOCAL_X_DIM 4 
#define LOCAL_Y_DIM 4
#define LOCAL_Z_DIM 4
#define THREAD_COUNT (LOCAL_X_DIM * LOCAL_Y_DIM * LOCAL_Z_DIM)
#define SCAN_BLOCK_SIZE (THREAD_COUNT * 2 + (THREAD_COUNT * 2 >> 4)) //136 // 128 + (128 >> 4)
#define ACTIVE_FMM_BLOCKS_OFFSET 512 // TODO: from uniform

#define DEBUG_OFFSET 0.07
// Fast marching method cell node.
// 1 => Far.
// 2 => Band.
// 4 => Known.
struct FMM_Node {
    float value;
    uint tag;
};

struct FMM_Block {
    //uvec3 base_coord;
    uint index;
    uint band_points_count;
};

struct OutputVertex {
    vec3 pos;
    uint color_point_size;
};

struct AABB {
    vec4 min;
    vec4 max; 
};

layout(set=0, binding=0) uniform camerauniform {
    mat4 u_view_proj;
    vec4 camera_pos;
};

// This buffer holds the temporary prefix sum data.
layout(set = 0, binding = 1) buffer Prefix_sums {
    uint[] temp_prefix_sum;
};

layout(set = 0, binding = 2) buffer Points_out {
    OutputVertex[] output_points;
};

layout(set = 0, binding = 3) buffer FMM_Nodes {
    FMM_Node[] fmm_cells;
};

// This buffer is divided to two parts.
// The first part includes the actual FMM_Blocks.
// The second part includes the active FMM_Blocks.
layout(set = 0, binding = 4) buffer FMM_Blocks {
    FMM_Block[] fmm_block;
};

layout(local_size_x = LOCAL_X_DIM, local_size_y = LOCAL_Y_DIM, local_size_z = LOCAL_Z_DIM) in;

const float FONT_SIZE = 0.02;
const float FONT_OFFSET_Y = 1.2;
const uint MAX_NUM_OF_POINTS = 700;

//// Super clever hack to avoid if :).
const uint blah[2] = {0, 0xffffffff};

uint local_id_to_x() { return gl_LocalInvocationID.x + LOCAL_X_DIM * gl_LocalInvocationID.y + LOCAL_X_DIM * LOCAL_Z_DIM * gl_LocalInvocationID.z; }


const uint[10] joo = {1,
                      10,
                      100,
                      1000,
                      10000,
                      100000,
                      1000000,
                      10000000,
                      100000000,
                      1000000000};

struct CharInformation {
    uint counter;
    vec3 position;
    uint[MAX_NUM_CHARS] chars;
};

// 2 x float
shared uint[2] counter;

// 136 x float
// The auxiliar scan block array
shared uint shared_aux[SCAN_BLOCK_SIZE];

// 136 x float
// The output of global active fmm block scan.
shared uint[SCAN_BLOCK_SIZE] shared_prefix_sum;

//// The counter for active fmm blocks.
shared uint stream_compaction_count;

// TODO: define a buffer for active scan blocks.
//shared FMM_Block[SCAN_BLOCK_SIZE * SCAN_BLOCK_COUNT] shared_stream_compaction;

// Debugging.
shared CharInformation[THREAD_COUNT] char_arrays;

const uvec3 local_dimension = uvec3(4,4,4);
const uvec3 group_dimension = uvec3(4,4,4);

const uint bez_indices[17] = {
    104| (108 << 8) | (112 << 16) | (116 << 24),  // 0       
    4  | (8 << 8) | (12 << 16) | (255 << 24),     // 1       
    16 | (20 << 8) | (24 << 16) | (255 << 24),    // 2       
    28 | (32 << 8) | (255 << 16) | (255 << 24),   // 3       
    36 | (40 << 8) | (44 << 16) | (255 << 24),    // 4       
    48 | (52 << 8) | (56 << 16) | (255 << 24),    // 5       
    60 | (64 << 8) | (68 << 16) | (255 << 24),    // 6       
    48 | (72 << 8) | (255 << 16) | (255 << 24),   // 7       
    76 | (80 << 8) | (84 << 16) | (88 << 24),     // 8       
    92 | (96 << 8) | (100 << 16) | (255 << 24),   // 9       
    0  | (255 << 8) | (255 << 16) | (255 << 24),  // 10
    104 | (112 << 8) | (255 << 16) | (255 << 24), // 11
    108 | (116 << 8) | (255 << 16) | (255 << 24), // 12
    148 | (152 << 8) | (156 << 16) | (160 << 24), // 13
    120 | (124 << 8) | (128 << 16) | (132 << 24), // 14
    136 | (140 << 8) | (144 << 16) | (255 << 24), // 15
    255 | (255 << 8) | (255 << 16) | (255 << 24), // 16
};

const vec4 bez_table[164] = {
    // Bez minus. 
    vec4(0.3, 0.5, 0.0, 0.25),     // 0
    vec4(0.433333, 0.5, 0.0, 0.0), // 1
    vec4(0.566666, 0.5, 0.0, 0.0), // 2
    vec4(0.7, 0.5, 0.0, 0.0),      // 3 

    // Bez 1.
    vec4(0.3, 0.1, 0.0, 4.0/14.0), // 4
    vec4(0.433333, 0.1, 0.0, 0.0), // 5
    vec4(0.566666, 0.1, 0.0, 0.0), // 6
    vec4(0.7, 0.1, 0.0, 0.0),      // 7 
    vec4(0.5, 0.1, 0.0, 8.0/14.0), // 8
    vec4(0.5, 0.366666, 0.0, 0.0), // 9
    vec4(0.5, 0.633333, 0.0, 0.0), // 10 
    vec4(0.5, 0.9, 0.0, 0.0),      // 11 
    vec4(0.5, 0.9, 0.0, 2.0/14.0), // 12 
    vec4(0.4, 0.8, 0.0, 0.0),      // 13 
    vec4(0.35, 0.8, 0.0, 0.0),     // 14 
    vec4(0.3, 0.8, 0.0, 0.0),      // 15 

    // Bez 2.
    vec4(0.3, 0.1, 0.0, 5.0/15.0),  // 16 
    vec4(0.433333, 0.1, 0.0, 0.0),  // 17 
    vec4(0.566666, 0.1, 0.0, 0.0),  // 18 
    vec4(0.7, 0.1, 0.0, 0.0),       // 19 
    vec4(0.3, 0.1, 0.0, 5.5/15.0),  // 20 
    vec4(0.416666, 0.3, 0.0, 0.0),  // 21 
    vec4(0.533333, 0.4, 0.0, 0.0),  // 22
    vec4(0.65, 0.55, 0.0, 0.0),     // 23 
    vec4(0.65, 0.55, 0.0, 6.5/15.0),// 24 
    vec4(0.8, 0.7, 0.0, 0.0),       // 25
    vec4(0.55, 1.08, 0.0, 0.0),     // 26
    vec4(0.3, 0.8, 0.0, 0.0),       // 27

    // Number 3
    vec4(0.3, 0.8, 0.0, 0.5),      // 28
    vec4(0.5, 1.1, 0.0, 0.0),      // 29
    vec4(0.95, 0.7, 0.0, 0.0),     // 30
    vec4(0.45, 0.55, 0.0, 0.0),    // 31
    vec4(0.45, 0.55, 0.0, 0.5),    // 32
    vec4(1.0, 0.45, 0.0, 0.0),     // 33
    vec4(0.5, -0.15, 0.0, 0.0),    // 34
    vec4(0.3, 0.2, 0.0, 0.0),      // 35

    // Number 4
    vec4(0.6, 0.1, 0.0, 8.0/17.0),   // 36
    vec4(0.6, 0.3666666, 0.0, 0.0),  // 37
    vec4(0.6, 0.6333333, 0.0, 0.0),  // 38
    vec4(0.6, 0.9, 0.0, 0.0),        // 39
    vec4(0.6, 0.9, 0.0, 5.0/17.0),   // 40
    vec4(0.466666, 0.75, 0.0, 0.0),  // 41
    vec4(0.333333, 0.6, 0.0, 0.0),   // 42
    vec4(0.2, 0.45, 0.0, 0.0),       // 43
    
    vec4(0.2, 0.45, 0.0, 4.0/17.0),  // 44
    vec4(0.3666666, 0.45, 0.0, 0.0), // 45
    vec4(0.5333333, 0.45, 0.0, 0.0), // 46
    vec4(0.7, 0.45, 0.0, 0.0),       // 47
    
    // Number 5.
    vec4(0.3, 0.9, 0.0, 2.0/13.0),  // 48
    vec4(0.433333, 0.9, 0.0, 0.0),  // 49
    vec4(0.566666, 0.9, 0.0, 0.0),  // 50
    vec4(0.7, 0.9, 0.0, 0.0),       // 51
    vec4(0.3, 0.5, 0.0, 2.0/13.0),  // 52
    vec4(0.3, 0.633333, 0.0, 0.0),  // 53
    vec4(0.3, 0.766666, 0.0, 0.0),  // 54
    vec4(0.3, 0.9, 0.0, 0.0),       // 55
    vec4(0.3, 0.5, 0.0, 9.0/13.0),  // 56
    vec4(1.0, 0.75, 0.0, 0.0),      // 57
    vec4(0.7, -0.2, 0.0, 0.0),      // 58
    vec4(0.3, 0.2, 0.0, 0.0),       // 59

    // Number 6
    vec4(0.7, 0.8, 0.0, 5.0/21.0),  // 60
    vec4(0.5, 1.05, 0.0, 0.0),      // 61
    vec4(0.3, 0.8, 0.0, 0.0),       // 62
    vec4(0.3, 0.5, 0.0, 0.0),       // 63
    vec4(0.3, 0.5, 0.0, 9.0/21.0),  // 64
    vec4(0.3, -0.05, 0.0, 0.0),     // 65
    vec4(0.7, 0.0, 0.0, 0.0),       // 66
    vec4(0.72, 0.4, 0.0, 0.0),      // 67
    vec4(0.72, 0.4, 0.0, 5.0/21.0), // 68
    vec4(0.72, 0.6, 0.0, 0.0),      // 69
    vec4(0.5, 0.7, 0.0, 0.0),       // 70
    vec4(0.3, 0.5, 0.0, 0.0),       // 71
    
    // Number 7 .
    // five_bez_a
    vec4(0.4, 0.1, 0.0, 6.0/13.0), // 72
    vec4(0.5, 0.366666, 0.0, 0.0), // 73
    vec4(0.6, 0.633333, 0.0, 0.0), // 74
    vec4(0.7, 0.9, 0.0, 0.0),      // 75
    
    
    // Number 8
    vec4(0.5, 0.9, 0.0, 0.25), // 76
    vec4(0.2, 0.85, 0.0, 0.0), // 77
    vec4(0.2, 0.55, 0.0, 0.0), // 78
    vec4(0.5, 0.5, 0.0, 0.0),  // 79
    vec4(0.5, 0.9, 0.0, 0.25), // 80
    vec4(0.8, 0.85, 0.0, 0.0), // 81
    vec4(0.8, 0.55, 0.0, 0.0), // 82
    vec4(0.5, 0.5, 0.0, 0.0),  // 83
    vec4(0.5, 0.1, 0.0, 0.25), // 84
    vec4(0.8, 0.15, 0.0, 0.0), // 85
    vec4(0.8, 0.45, 0.0, 0.0), // 86
    vec4(0.5, 0.5, 0.0, 0.0),  // 87
    vec4(0.5, 0.1, 0.0, 0.25), // 88
    vec4(0.2, 0.15, 0.0, 0.0), // 89
    vec4(0.2, 0.45, 0.0, 0.0), // 90
    vec4(0.5, 0.5, 0.0, 0.0),  // 91
    
    // Number 9
    vec4(0.3, 0.2, 0.0, 8.0/20.0), // 92
    vec4(0.5, -0.05, 0.0, 0.0),    // 93
    vec4(0.7, 0.2, 0.0, 0.0),      // 94
    vec4(0.7, 0.6, 0.0, 0.0),      // 95
    vec4(0.7, 0.6, 0.0, 6.0/20.0), // 96
    vec4(0.7, 0.95, 0.0, 0.0),     // 97
    vec4(0.4, 1.0, 0.0, 0.0),      // 98
    vec4(0.28, 0.8, 0.0, 0.0),     // 99
    vec4(0.28, 0.8, 0.0, 6.0/20.0),// 100
    vec4(0.1, 0.4, 0.0, 0.0),      // 101
    vec4(0.6, 0.4, 0.0, 0.0),      // 102
    vec4(0.7, 0.6, 0.0, 0.0),      // 103
    
    // Number 0 
    vec4(0.5, 0.9, 0.0, 0.25),   // 104
    vec4(0.25, 0.85, 0.0, 0.0),  // 105
    vec4(0.25, 0.55, 0.0, 0.0),  // 106
    vec4(0.25, 0.5, 0.0, 0.0),   // 107
    vec4(0.5, 0.9, 0.0, 0.25),   // 108
    vec4(0.75, 0.85, 0.0, 0.0),  // 109
    vec4(0.75, 0.55, 0.0, 0.0),  // 110
    vec4(0.75, 0.5, 0.0, 0.0),   // 111
    vec4(0.5, 0.1, 0.0, 0.25),   // 112
    vec4(0.25, 0.15, 0.0, 0.0),  // 113
    vec4(0.25, 0.45, 0.0, 0.0),  // 114
    vec4(0.25, 0.5, 0.0, 0.0),   // 115
    vec4(0.5, 0.1, 0.0, 0.25),   // 116
    vec4(0.75, 0.15, 0.0, 0.0),  // 117
    vec4(0.75, 0.45, 0.0, 0.0),  // 118
    vec4(0.75, 0.5, 0.0, 0.0),   // 119
    
    // Number inf 
    vec4(0.5, 0.5, 0.0, 0.25),   // 120
    vec4(0.4, 0.7, 0.0, 0.0),    // 121
    vec4(0.2, 0.7, 0.0, 0.0),    // 122
    vec4(0.1, 0.5, 0.0, 0.0),    // 123  
    vec4(0.1, 0.5, 0.0, 0.25),   // 124
    vec4(0.2, 0.3, 0.0, 0.0),    // 125
    vec4(0.4, 0.3, 0.0, 0.0),    // 126
    vec4(0.5, 0.5, 0.0, 0.0),    // 127  
    vec4(0.5, 0.5, 0.0, 0.25),   // 128
    vec4(0.6, 0.7, 0.0, 0.0),    // 129
    vec4(0.8, 0.7, 0.0, 0.0),    // 130
    vec4(0.9, 0.5, 0.0, 0.0),    // 131  
    vec4(0.9, 0.5, 0.0, 0.25),   // 132
    vec4(0.8, 0.3, 0.0, 0.0),    // 133
    vec4(0.6, 0.3, 0.0, 0.0),    // 134
    vec4(0.5, 0.5, 0.0, 0.0),    // 135  
    
    // Nan
    vec4(0.2, 0.1, 0.0, 8.0/26.0), // 136
    vec4(0.2, 0.366666, 0.0, 0.0), // 137
    vec4(0.2, 0.633333, 0.0, 0.0), // 138
    vec4(0.2, 0.9, 0.0, 0.0),      // 139
    
    vec4(0.2, 0.9, 0.0, 10.0/26.0),// 140
    vec4(0.4, 0.633333, 0.0, 0.0), // 141
    vec4(0.6, 0.366666, 0.0, 0.0), // 142
    vec4(0.8, 0.1, 0.0, 0.0),      // 143
    
    vec4(0.8, 0.1, 0.0, 8.0/26.0), // 144
    vec4(0.8, 0.366666, 0.0, 0.0), // 145
    vec4(0.8, 0.633333, 0.0, 0.0), // 146
    vec4(0.8, 0.9, 0.0, 0.0),      // 147

    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.5, 0.9, 0.0, 0.15)),   // 148
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.25, 0.85, 0.0, 0.0)),  // 149
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.25, 0.55, 0.0, 0.0)),  // 150
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.25, 0.5, 0.0, 0.0)),   // 151
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.5, 0.9, 0.0, 0.15)),   // 152
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.75, 0.85, 0.0, 0.0)),  // 153
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.75, 0.55, 0.0, 0.0)),  // 154
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.75, 0.5, 0.0, 0.0)),   // 155
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.5, 0.1, 0.0, 0.15)),   // 156
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.25, 0.15, 0.0, 0.0)),  // 157
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.25, 0.45, 0.0, 0.0)),  // 158
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.25, 0.5, 0.0, 0.0)),   // 159
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.5, 0.1, 0.0, 0.15)),   // 160
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.75, 0.15, 0.0, 0.0)),  // 161
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.75, 0.45, 0.0, 0.0)),  // 162
    0.2 * (vec4(1.8, 0.0, 0.0, 0.0) + vec4(0.75, 0.5, 0.0, 0.0))    // 163
};

// Encode vector to "rgba" uint.
uint encode_rgba_u32(uint r, uint g, uint b, uint a) {
  uint col = 0;
  col = (r << 24) | (g << 16) | (b  << 8) | a;
  return col;
}

// Updates counter until MAX_NUM_CHARS is reached.
// Returns the counter value before incrementation. 
uint update_counter() {
    uint local_index = local_id_to_x();
    uint counter_now = char_arrays[local_index].counter;
    char_arrays[local_index].counter = min(counter_now + 1, MAX_NUM_CHARS-1);
    return counter_now;
}

void create_aabb_triangles(AABB aabb, uint r, uint b, uint g) {

    uint aabb_index = atomicAdd(counter[1], 24);

    const vec3 delta = aabb.max.xyz - aabb.min.xyz;
    const vec3 p0 = aabb.min.xyz;
    const vec3 p1 = aabb.min.xyz + vec3(delta.x , 0.0     , 0.0);
    const vec3 p2 = aabb.min.xyz + vec3(delta.x , delta.y , 0.0);
    const vec3 p3 = aabb.min.xyz + vec3(0.0     , delta.y , 0.0);
    const vec3 p4 = aabb.min.xyz + vec3(0.0     , 0.0     , delta.z);
    const vec3 p5 = aabb.min.xyz + vec3(delta.x , 0.0     , delta.z);
    const vec3 p6 = aabb.min.xyz + vec3(delta.x , delta.y , delta.z);
    const vec3 p7 = aabb.min.xyz + vec3(0.0     , delta.y , delta.z);

    OutputVertex p0_out = OutputVertex( p0, encode_rgba_u32(r, g, b, 0));
    OutputVertex p1_out = OutputVertex( p1, encode_rgba_u32(r, g, b, 0));
    OutputVertex p2_out = OutputVertex( p2, encode_rgba_u32(r, g, b, 0));
    OutputVertex p3_out = OutputVertex( p3, encode_rgba_u32(r, g, b, 0));
    OutputVertex p4_out = OutputVertex( p4, encode_rgba_u32(r, g, b, 0));
    OutputVertex p5_out = OutputVertex( p5, encode_rgba_u32(r, g, b, 0));
    OutputVertex p6_out = OutputVertex( p6, encode_rgba_u32(r, g, b, 0));
    OutputVertex p7_out = OutputVertex( p7, encode_rgba_u32(r, g, b, 0));
}


// TODO rename to triangles.
void create_output_points(AABB aabb, uint r, uint g, uint b) {

    uint aabb_index = atomicAdd(counter[1], 36);

    const vec3 delta = aabb.max.xyz - aabb.min.xyz;
    const vec3 p0 = aabb.min.xyz;
    const vec3 p1 = aabb.min.xyz + vec3(delta.x , 0.0     , 0.0);
    const vec3 p2 = aabb.min.xyz + vec3(delta.x , delta.y , 0.0);
    const vec3 p3 = aabb.min.xyz + vec3(0.0     , delta.y , 0.0);
    const vec3 p4 = aabb.min.xyz + vec3(0.0     , 0.0     , delta.z);
    const vec3 p5 = aabb.min.xyz + vec3(delta.x , 0.0     , delta.z);
    const vec3 p6 = aabb.min.xyz + vec3(delta.x , delta.y , delta.z);
    const vec3 p7 = aabb.min.xyz + vec3(0.0     , delta.y , delta.z);

    // FRONT.

    const float lf_factor = 0.3;
    const uint lfr = uint(r*lf_factor);
    const uint lfg = uint(g*lf_factor);
    const uint lfb = uint(b*lf_factor);

    output_points[aabb_index]   = OutputVertex(p6, encode_rgba_u32(lfr, lfg, lfb, 1)); 
    output_points[aabb_index+1] = OutputVertex(p7, encode_rgba_u32(lfr, lfg, lfb, 1)); 
    output_points[aabb_index+2] = OutputVertex(p4, encode_rgba_u32(lfr, lfg, lfb, 1)); 

    output_points[aabb_index+3] = OutputVertex(p4, encode_rgba_u32(lfr, lfg, lfb, 1)); 
    output_points[aabb_index+4] = OutputVertex(p5, encode_rgba_u32(lfr, lfg, lfb, 1)); 
    output_points[aabb_index+5] = OutputVertex(p6, encode_rgba_u32(lfr, lfg, lfb, 1)); 

    // RIGHT.

    const float lr_factor = 0.6;
    const uint lrr = uint(r*lr_factor);
    const uint lrg = uint(g*lr_factor);
    const uint lrb = uint(b*lr_factor);

    output_points[aabb_index+6] = OutputVertex(p5, encode_rgba_u32(lrr, lrg, lrb, 1)); 
    output_points[aabb_index+7] = OutputVertex(p1, encode_rgba_u32(lrr, lrg, lrb, 1)); 
    output_points[aabb_index+8] = OutputVertex(p2, encode_rgba_u32(lrr, lrg, lrb, 1)); 

    output_points[aabb_index+9]  = OutputVertex(p2, encode_rgba_u32(lrr, lrg, lrb, 1)); 
    output_points[aabb_index+10] = OutputVertex(p6, encode_rgba_u32(lrr, lrg, lrb, 1)); 
    output_points[aabb_index+11] = OutputVertex(p5, encode_rgba_u32(lrr, lrg, lrb, 1)); 

    // BACK.

    output_points[aabb_index+12] = OutputVertex(p2, encode_rgba_u32(r, g, b, 1)); 
    output_points[aabb_index+13] = OutputVertex(p1, encode_rgba_u32(r, g, b, 1)); 
    output_points[aabb_index+14] = OutputVertex(p0, encode_rgba_u32(r, g, b, 1)); 

    output_points[aabb_index+15] = OutputVertex(p3, encode_rgba_u32(r, g, b, 1)); 
    output_points[aabb_index+16] = OutputVertex(p2, encode_rgba_u32(r, g, b, 1)); 
    output_points[aabb_index+17] = OutputVertex(p0, encode_rgba_u32(r, g, b, 1)); 

    // LEFT.

    const float ll_factor = 0.6;
    const uint llr = uint(r*ll_factor);
    const uint llg = uint(g*ll_factor);
    const uint llb = uint(b*ll_factor);

    output_points[aabb_index+18] = OutputVertex(p7, encode_rgba_u32(llr, llg, llb, 1)); 
    output_points[aabb_index+19] = OutputVertex(p3, encode_rgba_u32(llr, llg, llb, 1)); 
    output_points[aabb_index+20] = OutputVertex(p0, encode_rgba_u32(llr, llg, llb, 1)); 

    output_points[aabb_index+21] = OutputVertex(p0, encode_rgba_u32(llr, llg, llb, 1)); 
    output_points[aabb_index+22] = OutputVertex(p4, encode_rgba_u32(llr, llg, llb, 1)); 
    output_points[aabb_index+23] = OutputVertex(p7, encode_rgba_u32(llr, llg, llb, 1)); 

    // TOP.

    const float lt_factor = 0.8;
    const uint ltr = uint(r*lt_factor);
    const uint ltg = uint(g*lt_factor);
    const uint ltb = uint(b*lt_factor);

    output_points[aabb_index+24] = OutputVertex(p7, encode_rgba_u32(ltr, ltg, ltb, 1)); 
    output_points[aabb_index+25] = OutputVertex(p6, encode_rgba_u32(ltr, ltg, ltb, 1)); 
    output_points[aabb_index+26] = OutputVertex(p2, encode_rgba_u32(ltr, ltg, ltb, 1)); 

    output_points[aabb_index+27] = OutputVertex(p2, encode_rgba_u32(ltr, ltg, ltb, 1)); 
    output_points[aabb_index+28] = OutputVertex(p3, encode_rgba_u32(ltr, ltg, ltb, 1)); 
    output_points[aabb_index+29] = OutputVertex(p7, encode_rgba_u32(ltr, ltg, ltb, 1)); 

    // BOTTOM.

    const float lb_factor = 0.15;
    const uint lbr = uint(r*lb_factor);
    const uint lbg = uint(g*lb_factor);
    const uint lbb = uint(b*lb_factor);

    output_points[aabb_index+30] = OutputVertex(p1, encode_rgba_u32(lbr, lbg, lbb, 1)); 
    output_points[aabb_index+31] = OutputVertex(p5, encode_rgba_u32(lbr, lbg, lbb, 1)); 
    output_points[aabb_index+32] = OutputVertex(p4, encode_rgba_u32(lbr, lbg, lbb, 1)); 

    output_points[aabb_index+33] = OutputVertex(p4, encode_rgba_u32(lbr, lbg, lbb, 1)); 
    output_points[aabb_index+34] = OutputVertex(p0, encode_rgba_u32(lbr, lbg, lbb, 1)); 
    output_points[aabb_index+35] = OutputVertex(p1, encode_rgba_u32(lbr, lbg, lbb, 1)); 
}

void create_aabb_triangles_r(AABB aabb, uint r, uint g, uint b, float t) {
    AABB back_bottom = AABB(aabb.min, vec4(aabb.max.x, aabb.min.y + t, aabb.min.z + t, 1.0));
    AABB right_bottom = AABB(aabb.min, vec4(aabb.min.x + t, aabb.min.y + t, aabb.max.z, 1.0));
    AABB left_bottom = AABB(vec4(aabb.max.x - t, aabb.min.y, aabb.min.z, 1.0),
                            vec4(aabb.max.x, aabb.min.y + t, aabb.max.z, 1.0));
    AABB front_bottom = AABB(vec4(aabb.min.x, aabb.min.y, aabb.max.z - t, 1.0),
                             vec4(aabb.max.x, aabb.min.y + t, aabb.max.z, 1.0));

    AABB back_top = AABB(vec4(aabb.min.x, aabb.max.y - t, aabb.min.z, 1.0),  
                         vec4(aabb.max.x, aabb.max.y,     aabb.min.z + t, 1.0));
    AABB left_top = AABB(vec4(aabb.min.x,     aabb.max.y - t, aabb.min.z, 1.0),  
                          vec4(aabb.min.x + t, aabb.max.y,     aabb.max.z, 1.0));
    AABB right_top = AABB(vec4(aabb.max.x - t, aabb.max.y - t, aabb.min.z, 1.0),  
                          vec4(aabb.max.x,     aabb.max.y,     aabb.max.z, 1.0));
    AABB front_top = AABB(vec4(aabb.min.x,     aabb.max.y - t, aabb.max.z - t, 1.0),  
                          vec4(aabb.max.x,     aabb.max.y,     aabb.max.z, 1.0));
    AABB back_left_ud = AABB(vec4(aabb.min.x,     aabb.min.y, aabb.min.z, 1.0),  
                             vec4(aabb.min.x + t, aabb.max.y, aabb.min.z + t, 1.0));
    AABB back_right_ud = AABB(vec4(aabb.max.x - t, aabb.min.y, aabb.min.z, 1.0),  
                              vec4(aabb.max.x    , aabb.max.y, aabb.min.z + t, 1.0));
    AABB front_right_ud = AABB(vec4(aabb.min.x,    aabb.min.y, aabb.max.z - t, 1.0),  
                              vec4(aabb.min.x + t, aabb.max.y, aabb.max.z, 1.0));
    AABB front_left_ud = AABB(vec4(aabb.max.x - t, aabb.min.y, aabb.max.z - t, 1.0),  
                              vec4(aabb.max.x    , aabb.max.y, aabb.max.z, 1.0));
    create_output_points(back_bottom, r, g, b); 
    create_output_points(right_bottom, r, g, b); 
    create_output_points(left_bottom, r, g, b); 
    create_output_points(front_bottom, r, g, b); 
    create_output_points(back_top, r, g, b); 
    create_output_points(left_top, r, g, b); 
    create_output_points(right_top, r, g, b); 
    create_output_points(front_top, r, g, b); 
    create_output_points(back_left_ud, r, g, b); 
    create_output_points(back_right_ud, r, g, b); 
    create_output_points(front_right_ud, r, g, b); 
    create_output_points(front_left_ud, r, g, b); 
}


void bezier_4c(uint n, vec4 c0, vec4 c1, vec4 c2, vec4 c3, uint r, uint g, uint b) {

    if (n < 4) return;

    uint index = atomicAdd(counter[0], n);

    for (int i=0 ; i<n ; i++) {
        const float t = float(i)  / (float(n)-1.0);
        const float t2 = t * t;
        const float t3 = t2 * t;
        const float mt = 1.0 - t;
        const float mt2 = mt * mt;
        const float mt3 = mt2 * mt;
        const vec3 result = c0.xyz * mt3 + c1.xyz * 3.0 * mt2*t + c2.xyz * 3.0 * mt*t2 + c3.xyz * t3;
        const float dist = min(max(1.0, distance(camera_pos.xyz, result)), 255);
        output_points[index] = OutputVertex(
            result,
            encode_rgba_u32(
                r,
                g,
                b,
                uint(dist)));
        index++;
    }
}

void create_array(float array_width, vec3 base_pos, vec3 dest_pos, uint r, uint g, uint b) {

    vec3 array_direction = normalize(dest_pos - base_pos);
    vec3 camera_direction = normalize(camera_pos.xyz - base_pos);

    // Array length.
    float array_length = distance(dest_pos, base_pos);
    float array_base_length = array_length - array_width;

    vec3 side_direction = cross(camera_direction, array_direction);   

    uint index = atomicAdd(counter[1], 21);

    const vec3 p0 = base_pos;
    const vec3 p1 = base_pos + side_direction * array_width;
    const vec3 p2 = base_pos - side_direction * array_width;
    const vec3 p3 = p1 + array_direction * array_base_length;
    const vec3 p4 = p2 + array_direction * array_base_length;
    const vec3 p5 = base_pos + array_direction * array_base_length;
    const vec3 p6 = dest_pos;
    const vec3 p7 = p3 + side_direction * array_width * 2.0;
    const vec3 p8 = p4 - side_direction * array_width * 2.0;

    output_points[index]   = OutputVertex(p1, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+1] = OutputVertex(p0, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+2] = OutputVertex(p3, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+3] = OutputVertex(p0, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+4] = OutputVertex(p5, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+5] = OutputVertex(p3, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+6] = OutputVertex(p0, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+7] = OutputVertex(p2, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+8] = OutputVertex(p4, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+9] = OutputVertex(p4, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+10] = OutputVertex(p5, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+11] = OutputVertex(p0, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+12] = OutputVertex(p3, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+13] = OutputVertex(p4, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+14] = OutputVertex(p6, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+15] = OutputVertex(p3, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+16] = OutputVertex(p6, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+17] = OutputVertex(p7, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+18] = OutputVertex(p4, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+19] = OutputVertex(p8, encode_rgba_u32(r, g, b, 1)); 
    output_points[index+20] = OutputVertex(p6, encode_rgba_u32(r, g, b, 1)); 
}

uint get_remainder(uint num, uint divisor) {
    return (num - divisor * (num / divisor));
}

void log_number(uint n, bool ignore_first) {
       // 4294967295 
       // 1000000000
    uint local_index = local_id_to_x();

    bool found = false;
    bool ignore = ignore_first;
    uint temp_n = n;

    if (n == 0) {
        char_arrays[local_index].chars[update_counter()] = 0;
        return;
    }

    for (int i=9 ; i>=0 ; i--) {
        uint remainder = temp_n / joo[i];  
        temp_n -= remainder * joo[i];
        if (remainder != 0) {
            found = true;	    
        }
        if (found == true) {
            if (ignore == true) { ignore = false; continue; }
            char_arrays[local_index].chars[update_counter()] = remainder; 
        }
    }
}

void create_char(uint char_index, uint num_points, vec4 offset, uint r, uint g, uint b) {

    uint index = bez_indices[char_index];

    uint indices[4] = {
        index & 0xff,
        (index & 0xff00) >> 8,
        (index & 0xff0000) >> 16,
        (index & 0xff000000) >> 24,
    };

    for (uint i=0 ; i<4 ; i++) {
        uint bez_index = indices[i];
        if (bez_index == 255) break;
        vec4 bi = bez_table[bez_index];
        uint count = uint(max(1.0, num_points * bi.w));
        bezier_4c(
            count,
            FONT_SIZE * bez_table[bez_index + 0] + offset,
            FONT_SIZE * bez_table[bez_index + 1] + offset,
            FONT_SIZE * bez_table[bez_index + 2] + offset,
            FONT_SIZE * bez_table[bez_index + 3] + offset,
            r,
            g,
            b
        );
    }
}

void log_float(double f, uint max_decimals) {

    uint local_index = local_id_to_x();
    //uint counter_now = counter;

    // The sign of given float.
    bool is_negative = f < 0.0;

    // Add minus.
    if (is_negative) {
        char_arrays[local_index].chars[update_counter()] = 10;
        //char_arrays[local_index].counter++;
    }

    double f_positive = abs(f);

    // The integer part.
    float integer_temp; 

    // The fractional component.
    double _f_part = modf(float(f_positive), integer_temp);

    double f_part = fract(f_positive);

    // Multiply fractional part so it becomes uint.
    uint fract_part = uint((f_part+1.0)*joo[max_decimals]); //pow(10.0, max_decimals));

    // Cast integer part to uint.
    uint integer_part = uint(abs(integer_temp));

    // Parse the integer part.
    log_number(integer_part, false);

    // Add dot.
    char_arrays[local_index].chars[update_counter()] = 13;

    // Parse the frag part.
    log_number(fract_part, true);
}

void log_uvec3(uvec3 v) {

    uint local_index = local_id_to_x();

    // Add left paren.
    char_arrays[local_index].chars[update_counter()] = 11;

    log_number(v.x, false);

    // Add space x 2.
    char_arrays[local_index].chars[update_counter()] = 16;
    char_arrays[local_index].chars[update_counter()] = 16;

    log_number(v.y, false);

    // Add space x 2.
    char_arrays[local_index].chars[update_counter()] = 16;
    char_arrays[local_index].chars[update_counter()] = 16;

    log_number(v.z, false);
    
    // Add right paren.
    char_arrays[local_index].chars[update_counter()] = 12;

}

void log_vec3(vec3 v, uint max_decimals) {
    
    uint local_index = local_id_to_x();

    // Add left paren.
    char_arrays[local_index].chars[update_counter()] = 11;

    log_float(double(v.x), 7);

    // Add space x 2.
    char_arrays[local_index].chars[update_counter()] = 16;
    char_arrays[local_index].chars[update_counter()] = 16;

    log_float(double(v.y), 7);

    // Add space x 2.
    char_arrays[local_index].chars[update_counter()] = 16;
    char_arrays[local_index].chars[update_counter()] = 16;

    log_float(double(v.z), 7);
    
    // Add right paren.
    char_arrays[local_index].chars[update_counter()] = 12;
}

AABB create_char_sequency_points(uint r, uint g, uint b) {

    uint local_index = local_id_to_x();
    vec3 base_vector = char_arrays[local_index].position;
    const float dist = distance(base_vector, camera_pos.xyz);
    uint average_points_per_char = max(4, uint(min(MAX_NUM_OF_POINTS, MAX_NUM_OF_POINTS / pow(dist, 2.0)))); 
    vec4 local_offset = vec4(base_vector, 0.0);
    uint number_of_lines = 0;
    uint max_text_width = 0;
    uint text_width = 0;
      
    for (uint i=0; i<char_arrays[local_index].counter; i++) {
        uint numb = char_arrays[local_index].chars[i];

        // end of line.
        if (numb == 17) {
            number_of_lines++;
            local_offset = vec4(base_vector, 0.0) + vec4(0.0, (-FONT_OFFSET_Y) * float(number_of_lines) * FONT_SIZE, 0.0, 0.0);
            if (text_width > max_text_width) {
                max_text_width = text_width;
                text_width = 0;
            }
        }
        else {
            create_char(numb, average_points_per_char, local_offset, r, g, b);
            local_offset = local_offset + vec4(FONT_SIZE * 0.7, 0.0, 0.0, 0.0);
            text_width++;
        }
    }

    AABB aabb = AABB(
      vec4(base_vector, 0.0) + vec4(-0.5 * FONT_SIZE, number_of_lines * (-FONT_OFFSET_Y - 0.1) * FONT_SIZE, -0.05, 0.0),
      vec4(base_vector, 0.0) + FONT_SIZE * vec4(max_text_width * 0.8, FONT_OFFSET_Y, 0.0, 0.0) + vec4(0.0,0.0,-0.001,0.0)
    );
    return aabb;
}

void add_end_of_line() {
    uint local_index = local_id_to_x();
    char_arrays[local_index].chars[char_arrays[local_index].counter] = 17;
    char_arrays[local_index].counter++;
}

void initialize_char_array(vec3 position) {

    uint local_index = local_id_to_x();

    char_arrays[local_index].counter = 0;
    char_arrays[local_index].position = position;
}

// Calculate value for chosen grid cell. 
//float solve_quadratic(uvec3 grid_coord, float new_known_value) {
//    
//        // Best cell values in x-y-z directions. Values are calculated 
//        // from known cell neighbors only.
//        vec3 phis = vec3(0.0, 0.0, 0.0);
//
//        // For debugging.
//        //let mut chosen_neighbors: Vec<CellIndex> = Vec::new();
//
//        // TODO: add arrays for chosen neighbors.
//
//        // x-direction.
//        //let mut phis = [0.0, 0.0, 0.0];
//
//        // Deltas. 
//        let mut hs: [f32; 3] = [0.0, 0.0, 0.0];
//
//        // Directions.
//        int d0 = 0;
//        int d1 = 0;
//        int d2 = 0;
//
//        float dist_x_minus = 0.0;
//        float dist_x_plus  = 0.0;
//
//        //The grid x-length.
//        float h = 1.0; // / self.domain.grid_length;
//
//        // Get the values of known neigbors.
//        float neighbors[6] = {get_, 500000.0, 500000.0, 500000.0, 500000.0, 500000.0 }; 
//
//        // Check for the cell in -x direction.
//
//        // Cell x-coordinate must be greater than zero before it can access 
//        // its -x neighbor.
//        if (i > 0) {
//
//
//            
//            if let Some(cell) = self.domain.get_data(CellIndex {i: i-1, j: j, k: k}) {
//                match cell {
//                    Cell::Known(dist,_,sign) => {
//                        //assert!(sign, "A negative sign!");
//                        if sign {
//                            dist_x_minus = dist; d0 = -1;
//                        }
//                        // println!("KNOWN::CellIndex {{ i: {}, j: {}, k: {} }} is a known point. The dist is {}.", i-1, j, k, dist);
//                        }
//                    _ => { /*println!("CellIndex {{ i: {}, j: {}, k: {} }} is not a known point.", i-1, j, k);*/ } 
//                }
//            }
//        }
//        if let Some(cell) = self.domain.get_data(CellIndex {i: i+1, j: j, k: k}) {
//            match cell {
//                Cell::Known(dist,_,sign) => {
//                    //assert!(sign, "A negative sign!");
//                    if sign {
//                        dist_x_plus = dist;
//                        // println!("KNOWN::CellIndex {{ i: {}, j: {}, k: {} }} is a known point. The dist is {}.", i+1, j, k, dist);
//                        if d0 == 0 { d0 = 1; }
//                        else if dist_x_plus < dist_x_minus { d0 = 1; }
//                    }
//                }
//                _ => { /* println!("CellIndex {{ i: {}, j: {}, k: {} }} is not a known point.", i+1, j, k); */}
//            }
//        }
//        if d0 == -1  {
//            phis[0] = dist_x_minus;  
//            chosen_neighbors.push(CellIndex {i: i-1, j: j, k: k});
//            hs[0] = h;
//        }
//        if d0 == 1 {
//            phis[0] = dist_x_plus;  
//            chosen_neighbors.push(CellIndex {i: i+1, j: j, k: k});
//            hs[0] = h;
//        }
//
//        // y-direction.
//        let mut dist_y_minus = 0.0;
//        let mut dist_y_plus  = 0.0;
//
//        if j > 0 {
//            if let Some(cell) = self.domain.get_data(CellIndex {i: i, j: j-1, k: k}) {
//                match cell {
//                    Cell::Known(dist,_,sign) => {
//                    //assert!(sign, "A negative sign!");
//                        if sign {
//                            dist_y_minus = dist; d1 = -1;
//                            // println!("KNOWN::CellIndex {{ i: {}, j: {}, k: {} }} is a known point. The dist is {}.", i, j-1, k, dist);
//                            }
//                        }
//                    _ => { /* println!("CellIndex {{ i: {}, j: {}, k: {} }} is not a known point.", i, j-1, k); */}
//                }
//            }
//        }
//        if let Some(cell) = self.domain.get_data(CellIndex {i: i, j: j+1, k: k}) {
//            match cell {
//                Cell::Known(dist,_,sign) => {
//                    //assert!(sign, "A negative sign!");
//                    if sign {
//                        dist_y_plus = dist;
//                        // println!("KNOWN::CellIndex {{ i: {}, j: {}, k: {} }} is a known point. The dist is {}.", i, j+1, k, dist);
//                        if d1 == 0 { d1 = 1; }
//                        else if dist_y_plus < dist_y_minus { d1 = 1; }
//                    }
//                }
//                _ => { /* println!("CellIndex {{ i: {}, j: {}, k: {} }} is not a known point.", i, j+1, k); */}
//            }
//        }
//        if d1 == -1  {
//            phis[1] = dist_y_minus;  
//            chosen_neighbors.push(CellIndex {i: i, j: j-1, k: k});
//            hs[1] = h;
//        }
//        if d1 == 1 {
//            phis[1] = dist_y_plus;  
//            chosen_neighbors.push(CellIndex {i: i, j: j+1, k: k});
//            hs[1] = h;
//        }
//
//        // z-direction.
//        d2 = 0;
//        let mut dist_z_minus = 0.0;
//        let mut dist_z_plus  = 0.0;
//        if k > 0 {
//            if let Some(cell) = self.domain.get_data(CellIndex {i: i, j: j, k: k-1}) {
//                match cell {
//                    Cell::Known(dist,_,sign) => {
//                    //assert!(sign, "A negative sign!");
//                        if sign {
//                            dist_z_minus = dist; d2 = -1;
//                            //println!("KNOWN::CellIndex {{ i: {}, j: {}, k: {} }} is a known point. The dist is {}.", i, j, k-1, dist);
//                        }
//                    }
//                    _ => { /* println!("CellIndex {{ i: {}, j: {}, k: {} }} is not a known point.", i, j, k-1); */ }
//                }
//            }
//        }
//        if let Some(cell) = self.domain.get_data(CellIndex {i: i, j: j, k: k+1}) {
//            match cell {
//                Cell::Known(dist,_,sign) => {
//                    //assert!(sign, "A negative sign!");
//                    if sign {
//                        dist_z_plus = dist;
//                        //println!("KNOWN::CellIndex {{ i: {}, j: {}, k: {} }} is a known point. The dist is {}.", i, j, k+1, dist);
//                        if d2 == 0 { d2 = 1; }
//                        else if dist_z_plus < dist_z_minus { d2 = 1; }
//                    }
//                }
//                _ => { /* println!("CellIndex {{ i: {}, j: {}, k: {} }} is not a known point.", i, j, k+1); */}
//            }
//        }
//        if d2 == -1  {
//            phis[2] = dist_z_minus;  
//            chosen_neighbors.push(CellIndex {i: i, j: j, k: k-1});
//            hs[2] = h;
//        }
//        if d2 == 1 {
//            phis[2] = dist_z_plus;  
//            chosen_neighbors.push(CellIndex {i: i, j: j, k: k+1});
//            hs[2] = h;
//        }
//
//        if d0 == 0 && d1 == 0 && d2 == 0 {
//            panic!("Impossible! Solve quadradic all neighbors are not Known");
//        }
//
//        let mut a = 0.0;
//        let mut b = 0.0;
//        let mut c = 0.0;
//
//        for i in 0..3 {
//            a += hs[i].powf(2.0);
//            //println!("i.powf(2.0) == {}", i.powf(2.0));
//        }
//        for i in 0..3 {
//            b += hs[i].powf(2.0)*phis[i]; 
//        }
//        b *= -2.0;
//        
//        for i in 0..3 {
//            c += hs[i].powf(2.0) * phis[i].powf(2.0);
//        }
//
//        //c -= self.domain.grid_length.powf(2.0); // hs[0].powf(2.0);
//        //c -= (1.0/0.1 as f32).powf(2.0); // 1.0; // Speed function 1/(f_i,j,k)^2
//        c -= 1.0; // Speed function 1/(f_i,j,k)^2
//
//        //let mut result = Cell::Band(0.0, Vector3::<f32>::new(0.0, 0.0, 0.0));
//        let mut final_distance = 777.0;
//
//        let discriminant = b.powf(2.0) - (4.0*a*c);
//        // println!("discriminant == {}", discriminant);
//        // println!("2*a == {}", 2.0*a);
//
//        if discriminant >= 0.0 {
//            let t_phi = (-1.0*b + discriminant.sqrt()) / (2.0*a); 
//            //println!("t_phi == {}", t_phi);
//            if phis[0] < t_phi && phis[1] < t_phi && phis[2] < t_phi {
//                final_distance = t_phi; 
//            }
//            else {
//                if fix_band {
//                    return t_phi;
//                }
//                else {
//                    self.error_grids.push((CellIndex{i: i, j: j, k:k}, chosen_neighbors));
//                    println!("*********************************");
//                    println!("discriminant == {}", discriminant);
//                    println!("this_phi == {}", this_value);
//                    println!("t_phi == {}", t_phi);
//                    println!("hs[0] == {}", hs[0]);
//                    println!("hs[1] == {}", hs[1]);
//                    println!("hs[2] == {}", hs[2]);
//                    println!("phis[0] == {}", phis[0]);
//                    println!("phis[1] == {}", phis[1]);
//                    println!("phis[2] == {}", phis[2]);
//                }
//            }
//        }
//        else {
//            self.error_grids.push((CellIndex{i: i, j: j, k:k}, chosen_neighbors));
//            println!("++++++++++++++++++++++++");
//            println!("this_phi == {}", this_value);
//            println!("hs[0] == {}", hs[0]);
//            println!("hs[1] == {}", hs[1]);
//            println!("hs[2] == {}", hs[2]);
//            println!("phis[0] == {}", phis[0]);
//            println!("phis[1] == {}", phis[1]);
//            println!("phis[2] == {}", phis[2]);
//        }
//        final_distance
//    } 
//}

// Add the neighbor far points to the band. 
void update_neighbors(uvec3 grid_coord) {
    
    // Access all 6 directions. If a far point is found, mark it as band point.
}

// 
uint block_coord_to_block_index(uvec3 coord) {
  uint block_index = coord.x +
                     coord.y * 4 +
                     coord.z * 16;
  return block_index;
}

// For given block index,
uvec3 work_x_index_to_uvec3(uint work_index) {
  //uint work_index = gl_WorkGroupID.x;
  uint index = work_index;
  uint wh = group_dimension.x * group_dimension.y;
  uint z = index / wh;
  index -= z * wh;
  uint y = index / group_dimension.x;
  index -= y * group_dimension.x;
  uint x = index;
  return uvec3(x, y, z);
}

void push_chars(uint r, uint g, uint b) {

  uint local_index = local_id_to_x();
  vec3 original_coord = char_arrays[local_index].position;

  AABB aabb = create_char_sequency_points(255, 125, 125);
  AABB traslated = AABB(vec4(original_coord, 1.0), vec4(original_coord + vec3(1.0, 1.0, 1.0), 1.0));
  create_output_points(aabb,
                    r,
                    g,
                    b
                    );
  //initialize_char_array(new_base_coord);
}

// Add a chunk of block data to a temporary 'shared_perix_sum' buffer.
// Copies FMM_Block to shared_prefix_sum {0,1}. Add padding 0 if necessery.
void copy_block_to_temp(uint chunck_id, uint number_of_items) {

    // Create the local indices.
    const uint ai = local_id_to_x(); 
    const uint bi = ai + THREAD_COUNT;

    // Create the bank conflict free local indices.
    const uint ai_bcf = ai + (ai >> 4); 
    const uint bi_bcf = bi + (bi >> 4);

    // Create the global indices to access the global memory.
    const uint global_ai = ai + chunck_id * (THREAD_COUNT * 2);
    const uint global_bi = bi + chunck_id * (THREAD_COUNT * 2);

    // Create {0:1} array from the global fmm_block array.
    // 0 :: no band cells.
    // 1 :: band cells > 0.

    FMM_Block a = fmm_block[global_ai];
    FMM_Block b = fmm_block[global_bi];

    shared_prefix_sum[ai_bcf] = uint((ai < number_of_items) && (a.band_points_count > 0));
    shared_prefix_sum[bi_bcf] = uint((bi < number_of_items) && (b.band_points_count > 0));

    // const vec3 this_coord  = vec3((ai + chunck_id*(THREAD_COUNT * 2)) * DEBUG_OFFSET, 0.0, 0.0);
    // const vec3 this_coord2 = vec3((bi + chunck_id*(THREAD_COUNT * 2)) * DEBUG_OFFSET, 0.0, 0.0);
    // const vec3 this_coord  = vec3(ai * DEBUG_OFFSET, 0.0, 0.0);
    // const vec3 this_coord2 = vec3(bi * DEBUG_OFFSET, 0.0, 0.0);

    // initialize_char_array(this_coord + vec3(0.0, DEBUG_OFFSET * (chunck_id+4), 0.0));
    // log_number(ai + chunck_id*(THREAD_COUNT * 2), false);
    // add_end_of_line();
    // log_number(shared_prefix_sum[ai_bcf], false);
    // add_end_of_line();
    // push_chars(255 - local_id_to_x() * 4, local_id_to_x() * 4, 20);

    // initialize_char_array(this_coord2 + vec3(0.0, DEBUG_OFFSET * (chunck_id+4), 0.0));

    // log_number(bi + chunck_id*(THREAD_COUNT * 2), false);
    // add_end_of_line();
    // log_number(shared_prefix_sum[bi_bcf], false);
    // add_end_of_line();
    // push_chars(255 - local_id_to_x() * 4, local_id_to_x() * 4, 20);
}

void copy_prefix_sum_to_temp(uint chunck_id) {

    // Create the local indices.
    const uint ai = local_id_to_x(); 
    const uint bi = ai + THREAD_COUNT;

    // Create the bank conflict free local indices.
    const uint ai_bcf = ai + (ai >> 4); 
    const uint bi_bcf = bi + (bi >> 4);

    // Create the global indices to access the global memory.
    const uint global_ai = ai + chunck_id * (THREAD_COUNT * 2);
    const uint global_bi = bi + chunck_id * (THREAD_COUNT * 2);

    temp_prefix_sum[global_ai] = shared_prefix_sum[ai_bcf];
    temp_prefix_sum[global_bi] = shared_prefix_sum[bi_bcf];
}

// Perform prefix sum. Return the exclusive part of the prefix sum.
// NOTE: only the thread 0 returns the actual exclusive part.
uint local_prefix_sum() {

    // Create the local indices.
    const uint ai = local_id_to_x(); 
    const uint bi = ai + THREAD_COUNT;

    // Create the bank conflict free local indices.
    const uint ai_bcf = ai + (ai >> 4); 
    const uint bi_bcf = bi + (bi >> 4);

    uint exclusive_part = 0;

    // Up sweep.

    const int n = THREAD_COUNT*2;
    int offset = 1;
    for (int d = n>>1 ; d > 0; d >>= 1) {
      barrier();
      //if (local_id_x < d) {
      if (ai < d) {

          int ai_temp = offset*(int(ai*2)+1)-1; // 0, 2, 4, 6
          int bi_temp = offset*(int(ai*2)+2)-1; // 1, 3, 5, 7

          ai_temp += (ai_temp >> 4);
          bi_temp += (bi_temp >> 4);

          shared_prefix_sum[bi_temp] += shared_prefix_sum[ai_temp];
      }
      offset *= 2;
    }
    barrier();
      
    // Clear the last item. 
    if (ai == 0) {

        // Global last index.
        uint last_index = (THREAD_COUNT * 2) -1 + ((THREAD_COUNT * 2 - 1) >> 4);

        // Copy the last prefix sum to the shared_aux. 
        exclusive_part = shared_prefix_sum[last_index];

        // Add zero to the last index.
        shared_prefix_sum[last_index] = 0;
    }
    
    // Down sweep.
    for (int d = 1; d < n ; d *=2) {
      offset >>= 1;
      barrier();
      if (ai < d) {
          int ai_temp = offset*(int(ai*2)+1)-1;
          int bi_temp = offset*(int(ai*2)+2)-1;
          ai_temp += (ai_temp >> 4);
          bi_temp += (bi_temp >> 4);
          uint t = shared_prefix_sum[ai_temp];

          shared_prefix_sum[ai_temp] = shared_prefix_sum[bi_temp];
          shared_prefix_sum[bi_temp] += t;
      }
  }
  return exclusive_part;
}

// Perform prefix sum for shared_aux. Return the exclusive part of the prefix sum.
uint local_prefix_sum_aux() {

    // Create the local indices.
    const uint ai = local_id_to_x(); 
    const uint bi = ai + THREAD_COUNT;

    // Create the bank conflict free local indices.
    const uint ai_bcf = ai + (ai >> 4); 
    const uint bi_bcf = bi + (bi >> 4);

    uint exclusive_part = 0;

    // Up sweep.

    const int n = THREAD_COUNT*2;
    int offset = 1;
    for (int d = n>>1 ; d > 0; d >>= 1) {
      barrier();
      if (ai < d) {

          int ai_temp = offset*(int(ai*2)+1)-1; // 0, 2, 4, 6
          int bi_temp = offset*(int(ai*2)+2)-1; // 1, 3, 5, 7

          ai_temp += (ai_temp >> 4);
          bi_temp += (bi_temp >> 4);

          shared_aux[bi_temp] += shared_aux[ai_temp];
      }
      offset *= 2;
    }
    barrier();
      
    // Clear the last item. 
    if (ai == 0) {

        // Global last index.
        uint last_index = (THREAD_COUNT * 2) -1 + ((THREAD_COUNT * 2 - 1) >> 4);

        // Copy the last prefix sum to the shared_aux. 
        stream_compaction_count = shared_aux[last_index];

        // Add zero to the last index.
        shared_aux[last_index] = 0;
    }
    
    // Down sweep.
    for (int d = 1; d < n ; d *=2) {
      offset >>= 1;
      barrier();
      if (ai < d) {
          int ai_temp = offset*(int(ai*2)+1)-1;
          int bi_temp = offset*(int(ai*2)+2)-1;
          ai_temp += (ai_temp >> 4);
          bi_temp += (bi_temp >> 4);
          uint t = shared_aux[ai_temp];

          shared_aux[ai_temp] = shared_aux[bi_temp];
          shared_aux[bi_temp] += t;
      }
  }
  return exclusive_part;
}

// Stream compation.
void solve_active_fmm_block(uint number_of_scan_blocks) {

    uint local_id_x = local_id_to_x(); 

    for (int j=0 ; j < number_of_scan_blocks ; j++) {
    
      uint ai = local_id_x + j * THREAD_COUNT * 2;
      uint bi = (local_id_x + THREAD_COUNT) + j * THREAD_COUNT * 2;
    
      uint ai_active = ai + ACTIVE_FMM_BLOCKS_OFFSET;
      uint bi_active = bi + ACTIVE_FMM_BLOCKS_OFFSET;
    
      FMM_Block a = fmm_block[ai];
      FMM_Block b = fmm_block[bi];
    
      bool add_a = a.band_points_count > 0;
      bool add_b = b.band_points_count > 0;
    
      if (add_a) {
          uint index_to_add = temp_prefix_sum[ai];
          fmm_block[index_to_add + ACTIVE_FMM_BLOCKS_OFFSET] = a;
      }
      if (add_b) {
          uint index_to_add = temp_prefix_sum[bi];
          fmm_block[index_to_add + ACTIVE_FMM_BLOCKS_OFFSET] = b;
      }
    }
}

uint global_solver() {

  // This should come from the host program.
  const int number_of_blocks = 512; 

  // Convert 4x4x4 index to uint.
  uint local_id_x = local_id_to_x();

  // Reset the counter for active blocks. 
  if (local_id_x == 0) stream_compaction_count = 0;
  
  // Number of data chunks. There must be at least one iteration.
  // neeeded. TODO: check number_of_blocks == 0. Return immediatelly if it
  // true.
  const int number_of_scan_blocks = (number_of_blocks - 1) / 128 + 1;

  // Available items count.
  uint items_available = number_of_blocks;

  // The number of items on current chunk.
  uint number_of_taken_items = 0; 

  // Create the local indices.
  const uint ai = local_id_to_x(); 
  const uint bi = ai + THREAD_COUNT;

  // Create the local indices.
  const uint ai_bcf = ai + (ai >> 4); 
  const uint bi_bcf = bi + (bi >> 4);
  
  // Add zeroes to the shared_aux (the conflict free indexes).
  shared_aux[ai_bcf] = 0;
  shared_aux[bi_bcf] = 0;
  shared_prefix_sum[ai_bcf] = 8;
  shared_prefix_sum[bi_bcf] = 3;
  // barrier();

  // FMM_Blocks are converted to boolean array.
  // FMM_Block.band_points_count >  0 :: 1
  // FMM_Block.band_points_count == 0 :: 0
  // Perfom prefix sum on boolean array.
  for (int j=0 ; j < number_of_scan_blocks ; j++) {

      // Determine the count of items in this iteration.
      number_of_taken_items = min(THREAD_COUNT * 2, items_available);

      // Decrease the number of available items.
      items_available -= number_of_taken_items;

      // Copy data from global FMM_Block array to
      // shared_prefix_sum. [{0,1}]
      copy_block_to_temp(j, number_of_taken_items);

      // Perform the prefix_sum.
      uint exclusive_part = local_prefix_sum();

      // Add the exclusive part to the shared aux.
      if (local_id_x == 0) shared_aux[j + (j >> 4)] = exclusive_part; 

      // Copy local prefix sum data to 'temp_prefix_sum' buffer.
      copy_prefix_sum_to_temp(j);
  }

  // Perform the prefix_sum for shared_aux.
  uint aux_exclusive_part = local_prefix_sum_aux();

  // Add the shared_aux to the final result.
  for (int j=0 ; j < number_of_scan_blocks ; j++) {
    uint value_to_add = shared_aux[j + (j >> 4)]; 

    // Create the global indices to access the global memory.
    const uint global_ai = ai + j * (THREAD_COUNT * 2);
    const uint global_bi = bi + j * (THREAD_COUNT * 2);

    temp_prefix_sum[global_ai] += value_to_add; 
    temp_prefix_sum[global_bi] += value_to_add; 
  }

  // Finally. Update the number of active FMM_Blocks.

  solve_active_fmm_block(number_of_scan_blocks);

  return 777;
}

#define DBL_EPSILON 0.1

float calc_u(float phi_u, float phi_v, float r) {
    const float tol = 5.0e-3;
    //float r = 0.1; //RAND();
    float l = (2.0*phi_u - phi_v)/3.0;
    const int maxIter = 20;
    float u = 0.5;
    int n=0;
    while (n++ < maxIter) {
        float u1 = 1.0-u;
        float p  = u*(2.0-u) - l*u*u1*u1 - r;
        float pd = max(u1*(2.0 + l*(3.0*u-1.0)), DBL_EPSILON);
        float du = max(min(p/pd, 0.25), -0.25);
        u -= du;
        u = max(min(u, 1.0-DBL_EPSILON), DBL_EPSILON);
        if (abs(du) < tol) break;
    }
    return u;
} 

float calc_v(float u, float phi_u, float phi_v, float r) {
    //float r = 0.1; //RAND();
    const float epsilon = 1.0e-6;
    if (abs(phi_v) < epsilon) return (1.0 - u)*r;
    float tau = 1.0/3.0 - (1.0 + (u-1.0/3.0)*phi_u)/phi_v;
    float tmp = tau + u - 1.0;
    float q = sqrt(tau*tau*(1.0-r) + tmp*tmp*r);
    return tau <= 0.5*(1.0-u) ? tau + q : tau - q;
}

void sample_triangle(vec3 a, vec3 b, vec3 c, uint n) {
   vec2[25] sample_points = {
        vec2(0.0, 0.0),  vec2(0.25, 0.0),  vec2(0.5, 0.0),  vec2(0.75, 0.0),  vec2(1.0, 0.0), 
        vec2(0.05, 0.25), vec2(0.25, 0.25), vec2(0.5, 0.25), vec2(0.75, 0.25), vec2(1.0, 0.25), 
        vec2(0.05, 0.5),  vec2(0.25, 0.5),  vec2(0.5, 0.5),  vec2(0.75, 0.5),  vec2(1.0, 0.5), 
        vec2(0.05, 0.75), vec2(0.25, 0.75), vec2(0.5, 0.75), vec2(0.75, 0.75), vec2(1.0, 0.75), 
        vec2(0.05, 1.0),  vec2(0.25, 1.0),  vec2(0.5, 1.0),  vec2(0.75, 1.0),  vec2(1.0, 1.0) 
   };

   // vec2[25] sample_points;

   // for (int i=0 ; i<25 ; i++) {
   //   sample_points[i] = vec2(abs(sin(float(i))), abs(cos(float(i*3))));
   // }

   // vec3 weights = vec3(1.0, 0.5, 0.5);

   vec3 center = vec3(((a.x + b.x + c.x) / 3.0),
                      ((a.y + b.y + c.y) / 3.0),
                      ((a.z + b.z + c.z) / 3.0));
   float phi_x = distance(center, a); 
   float phi_y = distance(center, b); 
   float phi_z = distance(center, c); 

   const vec3 center_minus = center - vec3(0.01, 0.01, 0.01);
   const vec3 center_plus =  center + vec3(0.01, 0.01, 0.01);
   create_aabb_triangles_r(AABB(vec4(center_minus, 1.0), vec4(center_plus, 1.0)),
                               255,
                               10,
                               255,
                               0.025);
   //output_points[index] = OutputVertex(p, encode_rgba_u32(255, 0, 0, 50)); 

   uint index_triangle = atomicAdd(counter[1], 3);
   output_points[index_triangle] = OutputVertex(a, encode_rgba_u32(0, 255, 0, 1)); 
   output_points[index_triangle+1] = OutputVertex(b, encode_rgba_u32(0, 255, 0, 1)); 
   output_points[index_triangle+2] = OutputVertex(c, encode_rgba_u32(0, 255, 0, 1)); 

   // for (int i=0 ; i<25 ; i++) {
   //      float val = 1.0 / float(i+1);
   //      vec3 p = val * (phi_x - phi_z)
   // }

   // for (int i=0 ; i<25 ; i++) {
   //      float u = calc_u(sample_points[i].x, sample_points[i].y, 0.1*abs(sin(float(i))));
   //      float v = calc_v(u, sample_points[i].x, sample_points[i].y, 0.1*abs(cos(float(i+4))));
   //      float w = 1 - u - v;
   //      float the_u = sample_points[i].x;
   //      float the_v = sample_points[i].y;
   //      float the_w = 1.0 -  sample_points[i].x - sample_points[i].y;
   //      // const vec3 p = a * (sample_points[i].x - sample_points[i].y) +
   //      //                b * (sample_points[i].y - (1 - sample_points[i].x -
   //      //                sample_points[i].y)) + (1 - sample_points[i].x - sample_points[i].y);
   //      const float x = u * (the_u - the_w) +
   //                      v * (the_v - the_w) +
   //                      the_w;
   //      const vec3 p = u*a + v*b + (1-u-v)*c;
   //      const vec3 p_minus = p - vec3(0.01, 0.01, 0.01);
   //      const vec3 p_plus =  p + vec3(0.01, 0.01, 0.01);
   //      create_aabb_triangles_r(AABB(vec4(p_minus, 1.0), vec4(p_plus, 1.0)), 255, 10, 10, 0.005);
   // }

   //for (int i=0 ; i<25 ; i++) {

   //     // uint index = atomicAdd(counter[0], 1);

   //     const float z_square = pow(sample_points[i].x, 0.5);
   //     const vec3 p = (1.0 - z_square) * a +
   //                    z_square*(1.0 - sample_points[i].y) * b +
   //                    z_square * sample_points[i].y * c;
   //     const vec3 p_minus = p - vec3(0.01, 0.01, 0.01);
   //     const vec3 p_plus =  p + vec3(0.01, 0.01, 0.01);

   //     // initialize_char_array(p + vec3(0.0, DEBUG_OFFSET, 0.0));
   //     // log_float(sample_points[i].x, 3);
   //     // add_end_of_line();
   //     // log_float(sample_points[i].y, 3);
   //     // add_end_of_line();
   //     // push_chars(255 - local_id_to_x() * 4, local_id_to_x() * 4, 20);
   //                    
   //     create_aabb_triangles_r(AABB(vec4(p_minus, 1.0), vec4(p_plus, 1.0)),
   //                             uint(sample_points[i] * 255), 10,
   //                             uint(sample_points[i] * 255), 0.005);
   //     // output_points[index] = OutputVertex(p, encode_rgba_u32(255, 0, 0, 50)); 
   // }
}

void main() {

  // Finally add the counter[0] and counter[1] to the output_points[0] adn
  // output_points[1];
  //  uint index = atomicAdd(counter[1], 21);
  if (local_id_to_x() == 0) {
    counter[0] = 2;
    counter[1] = 1024000;
    //output_points[0] = OutputVertex(vec3(7,7,7), 2);
    //output_points[1] = OutputVertex(vec3(8,8,8), 1024000);
  }
  // barrier();

  // solve_active_fmm_blocks();
  ////global_solver();

  ////for (int j=0 ; j < 4 ; j++) {

  ////  uint ai = local_id_to_x();
  ////  uint bi = local_id_to_x() + THREAD_COUNT;

  ////  uint ai_global = ai + j*(THREAD_COUNT * 2);
  ////  uint bi_global = bi + j*(THREAD_COUNT * 2);

  ////  if (ai_global < stream_compaction_count) {

  ////      const vec3 this_coord  = vec3(ai_global * DEBUG_OFFSET, 0.0, 0.0);

  ////      initialize_char_array(this_coord + vec3(0.0, DEBUG_OFFSET * 2, 0.0));
  ////      log_number(ai_global, false);
  ////      add_end_of_line();
  ////      log_number(fmm_block[ai_global + ACTIVE_FMM_BLOCKS_OFFSET].index, false);
  ////      add_end_of_line();
  ////      push_chars(255 - local_id_to_x() * 4, local_id_to_x() * 4, 20);

  ////  }
  ////  if (bi_global < stream_compaction_count) {

  ////      const vec3 this_coord2 = vec3(bi_global * DEBUG_OFFSET, 0.0, 0.0);

  ////      initialize_char_array(this_coord2 + vec3(0.0, DEBUG_OFFSET * 2, 0.0));

  ////      log_number(bi_global, false);
  ////      add_end_of_line();
  ////      log_number(fmm_block[bi_global + ACTIVE_FMM_BLOCKS_OFFSET].index, false);
  ////      add_end_of_line();
  ////      push_chars(255 - local_id_to_x() * 4, local_id_to_x() * 4, 20);

  ////  }
  ////}

  // const vec3 v0 = vec3(0.5, 1.0, 0.7);
  // const vec3 v1 = vec3(0.8, 1.5, 0.2);
  // const vec3 v2 = vec3(0.2, 2.5, 1.0);
  // const vec3 v3 = vec3(10.0, 20.0, 15.0);
  // const vec3 v4 = vec3(12.0, 22.0, 17.0);
  // const vec3 v5 = vec3(13.0, 9.5, 13.0);
  // const vec3 v6 = vec3(1.0, 2.0, 3.0);
  // const vec3 v7 = vec3(0.0, 1.0, 0.0);
  // const vec3 v8 = vec3(3.0, 3.5, 3.8);
  // if (local_id_to_x() == 0) {
  //   sample_triangle(v0, v1, v2, 0);
  //   sample_triangle(v3, v4, v5, 0);
  //   sample_triangle(v6, v7, v8, 0);
  // }
  // //barrier();
  if (local_id_to_x() == 0) {
    output_points[0] = OutputVertex(vec3(7,7,7), counter[0]);
    output_points[1] = OutputVertex(vec3(8,8,8), counter[1]);
  }

  ////  uint global_index = gl_LocalInvocationID.x      + 64 * block.x +
  ////                      gl_LocalInvocationID.y * 4  + 64 * 4 * block.y +
  ////                      gl_LocalInvocationID.z * 16 + 64 * 4 * 4 * block.z;

  ////  uint local_index = local_id_to_x();
  ////  //uint work_index = gl_WorkGroupID.x;

  ////  //uint active_index = gl_WorkGroupID.x;

  ////  uvec3 this_coord = gl_LocalInvocationID + work_x_index_to_uvec3(active_index) * 4; // * 4; //index1D_to_index3D_custom(); 
  ////   	
  ////  // Check if block is active.
  ////  if (!(gl_WorkGroupID == uvec3(0, 0, 0) || gl_WorkGroupID == uvec3(1, 0, 0))) return;
  ////  
  ////  uvec3 this_coord_local = index1D_to_index3D_local(); 
  ////  uvec3 this_coord_group = index1D_to_index3D_group(); 

  ////  //uvec3 this_coord_global = index1D_to_index3D(); 

  ////  //uvec3 this_coord = gl_LocalInvocationID + gl_WorkGroupID * 4; //index1D_to_index3D_custom(); 

  ////  initialize_char_array(vec3(this_coord.x + 0.25, this_coord.y + 0.5, this_coord.z + 0.5));

  ////  // Log global index.
  ////  log_float(global_index, 7);
  ////  add_end_of_line();

  ////  // log_float(global_index, 7);
  ////  // add_end_of_line();

  ////  // log_float(global_index, 7);
  ////  // add_end_of_line();

  ////  // log_float(global_index, 7);
  ////  // add_end_of_line();

  ////  log_vec3(this_coord, 7);
  ////  add_end_of_line();

  ////  log_uvec3(block);
  ////  add_end_of_line();

  ////  vec4 local_offset = vec4(this_coord.x, this_coord.y, this_coord.z , 0.0);

  ////  // log_vec3(vec3(local_offset), 7);
  ////  // add_end_of_line();

  ////  uint work_color_x = gl_WorkGroupID.y * gl_WorkGroupID.z * 16; 
  ////  uint work_color_y = 255 - (gl_WorkGroupID.x * gl_WorkGroupID.z * 16); 

  ////  AABB aabb = create_char_sequency_points(255, 125, 125);
  ////  AABB traslated = AABB(vec4(this_coord, 1.0), vec4(this_coord + vec3(1.0, 1.0, 1.0), 1.0));
  ////  create_output_points(aabb,
  ////                    gl_WorkGroupID.x % 2 == 0 ? 50 : 200,
  ////                    gl_WorkGroupID.y % 2 == 0 ? 10 : 100,
  ////                    gl_WorkGroupID.z % 2 == 0 ? 50 : 200
  ////                    );
  ////  // create_aabb_triangles_r(traslated,
  ////  //                   255,
  ////  //                   0,
  ////  //                   0,
  ////  //                   0.01
  ////  // );

  ////  if (local_index == 0) {
  ////    AABB group = AABB(
  ////        vec4(this_coord, 1.0),
  ////        vec4(this_coord, 1.0) + vec4(4.0, 4.0, 4.0 , 1.0)
  ////    );

  ////    vec3 middle_point = (aabb.min.xyz + aabb.max.xyz) * 0.5;

  ////    // To the right.
  ////    create_array(0.02,
  ////                 middle_point,
  ////                 middle_point + vec3(1.0 - (aabb.max.x - middle_point.x), 0.0, 0.0),
  ////                 125,
  ////                 20,
  ////                 0
  ////    );
  ////    // To the left.
  ////    create_array(0.02,
  ////                 middle_point,
  ////                 middle_point + vec3(-1.0 + (aabb.max.x - middle_point.x), 0.0, 0.0),
  ////                 125,
  ////                 20,
  ////                 0 
  ////    );
  ////    // To back.
  ////    create_array(0.02,
  ////                 middle_point,
  ////                 middle_point + vec3(0.0, 0.0, -1.0 + (aabb.max.z - middle_point.z)),
  ////                 125,
  ////                 20,
  ////                 0 
  ////    );
  ////    // To front.
  ////    create_array(0.02,
  ////                 middle_point,
  ////                 middle_point + vec3(0.0, 0.0, 1.0 - (aabb.max.z - middle_point.z)),
  ////                 125,
  ////                 20,
  ////                 0 
  ////    );
  ////    // Up.
  ////    create_array(0.02,
  ////                 middle_point,
  ////                 middle_point + vec3(0.0, 1.0 - (aabb.max.y - middle_point.y), 0.0),
  ////                 125,
  ////                 20,
  ////                 0 
  ////    );
  ////    // Down.
  ////    create_array(0.02,
  ////                 middle_point,
  ////                 middle_point + vec3(0.0, -1.0 + (aabb.max.y - middle_point.y), 0.0),
  ////                 125,
  ////                 20,
  ////                 0 
  ////    );
  ////    create_aabb_triangles_r(group,
  ////                            gl_WorkGroupID.x % 2 == 0 ? 50 : 200,
  ////                            gl_WorkGroupID.y % 2 == 0 ? 10 : 100,
  ////                            gl_WorkGroupID.z % 2 == 0 ? 50 : 200,
  ////                            0.1
  ////    );
  ////  }

}
